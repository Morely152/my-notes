---

---
--- 
> 声明：本篇笔记摘自[《数据结构教程》 - 清华大学出版社](http://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC5%E7%89%88%EF%BC%89/22216268?fromModule=search-result_lemma)，遵循[CC BY 4.0协议](https://creativecommons.org/licenses/by/4.0/legalcode.zh-hans)。
> 存在由AI生成的小部分内容，仅供参考，请仔细甄别可能存在的错误。
--- 

# 一、排序的概念

- **排序**，就是指整理初始排序表中的元素，使其按照关键字递增或者递减有序排列；
- 对于排序表中关键字相同的元素，如果排序后它们的先后关系不变，称这样的排序算法是**稳定的**。反之，只要有两个元素关键字相同但排序后先后顺序变了，那么称排序算法是**不稳定的**；
- 若整个排序表都在内存中，排序时不涉及内存与外存的交互，则称之为**内排序**。若在排序时需要进行内、外存交互，称之为**外排序**；
- 本节笔记只讨论内排序。

以顺序表作为排序表的存储结构。假设关键字的类型为整型，排序表中数据元素的类型声明如下：

```cpp
typedef int KeyType;
typedef struct {
	KeyType key;         // 关键字项
	InfoType data;       // 其他数据
} RecType;               // 定义排序元素类型
```

# 二、插入排序

## 1.直接插入排序

将排序表划分为有序区和无序区，**直接插入排序**的操作是将当前无序区的开头元素插入有序区中的适当位置，使得加入一个新元素的有序区始终是有序的。继续如此操作，直到无序区不剩元素。

![](https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif)

算法实现如下：

```cpp
void InsertSort(RecType R[],int n)     //对 R[0..n-1]按递增有序进行直接插入排序
{
    int i, j; RecType tmp;
    for (i=1;i<n;i++)
    {
        if (R[i].key<R[i-1].key)       //反序时
        {
            tmp=R[i];
            j=i-1;
            do                         //找 R[i]的插入位置
            { 
                R[j+1]=R[j];           //将关键字大于 R[i].key 的记录后移
                j--;
            } while(j>=0 && R[j].key>tmp.key);
            R[j+1]=tmp;                //在 j+1 插入 R[i]
        }
    }
}
```

## 2.折半插入排序

**折半插入排序**的思路与直接插入排序相似，只是在寻找元素插入有序区的位置时，由于有序区已经排序，可以使用二分查找来确定插入的位置，从而加快排序的执行。

算法实现如下：

```cpp
void BinInsertSort(RecType R[],int n)
{
    int i,j,low, high, mid;
    RecType tmp;
    for (i=1;i<n;i++)
    {
        if (R[i].key < R[i-1].key)    //反序时
        {
            tmp=R[i];                //将R[i]保存到tmp中
            low=0;high=i-1;
            while (low<=high)        //在R[low..high]中查找插入的位置
            {
                mid=(low+high)/2;    //取中间位置
                if (tmp.key < R[mid].key)
                    high=mid-1;      //插入点在左半区
                else
                    low=mid+1;       //插入点在右半区
            }
            //插入点在high+1
            for (j=i-1;j>=high+1;j--)    //集中进行元素的后移
                R[j+1]=R[j];
            R[high+1]=tmp;               //插入tmp
        }
    }
}
```

## 3.希尔排序

**希尔排序**实际上是一种分组插入排序方法。基本思路如下：
1. 取一个小于n的整数，记为增量d，将表中的数据分为d个组
2. 将所有下标除d同余的数放到一个组中
3. 在各组内进行直接插入排序
4. 取第二个增量d’,然后循环1-4步骤，直到所有的元素划分在同一组中进行插入排序

![](https://i-blog.csdnimg.cn/blog_migrate/4f3d6ca502bddeb2b466cd2c2054be55.gif)

希尔排序也称为减少增量的排序方法。希尔排序中每趟不产生有序区，在最后一趟排序结束之前，所有元素都不一定能归位，但是在每趟完成后，数据的位置应当越来越接近有序。

算法实现如下：
```cpp
void ShellSort(RecType R[],int n)    //希尔排序算法
{
    int i,j,d;
    RecType tmp;
    d=n/2;                          //增量置初值
    while (d>0)
    {
        for (i=d;i<n;i++)           //对所有组采用直接插入排序
        {
            tmp=R[i];               //对相隔d个位置的一组采用直接插入排序
            j=i-d;
            while (j>=0 && tmp.key < R[j].key)
            {
                R[j+d]=R[j];
                j=j-d;
            }
            R[j+d]=tmp;
        }
        d=d/2;                      //减小增量
    }
}
```

---
![](20260112072458658.jpg)

--- 
# 三、交换排序
## 1.冒泡排序

将每个元素和右边相邻的元素比较关键字大小，如果比右边大就进行交换；直到某次遍历数组之后没有交换元素，停止排序，得到按关键字递增的有序表。

![](https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif)

算法实现如下：
```cpp
void BubbleSort1(RecType R[], int n) {
    int i, j;
    bool exchange;
    for (i = 0; i < n - 1; i++) {
        exchange = false;  // 一趟前exchange置为假
        for (j = n - 1; j > i; j--) {  // 归位R[i]，循环n-i-1次
            if (R[j].key < R[j - 1].key) {  // 相邻两个元素反序时
                swap(&R[j], &R[j - 1]);     // 将R[j]和R[j-1]两个元素交换
                exchange = true;            // 一旦有交换，exchange置为真
            }
        }
        if (!exchange)  // 本趟没有发生交换，中途结束算法
            return;
    }
}
```
## 2.快速排序

- 任取一个元素（一般取中间的）作为基准，将小于基准的放到左边，大于基准的放到右边。
- 对上述产生的两部分，分别再次进行取基准-调整左小右大的步骤，分别产生两个部分（称为一次划分）。
- 递归执行第二步，最终得到有序序列。

一次划分的具体操作：
- 取出基准的值，认为原地留下了一个“坑”
- 定义两个指针i和j，分别从左开始往右走和从右开始往左走；
	- i找到比基准大的数 -> 应该在基准右边 -> 将i所指的数与坑交换
	- j找到比基准小的数 -> 应该在基准左边 -> 将j所指的数与坑交换
- 直到i和j走到一起，剩下的“坑”就是基准的位置，将基准回填到坑中，基准的左右两边产生两个小的部分，下一次就在这两部分中递归地进行划分处理

![](https://i-blog.csdnimg.cn/direct/b1bdea2e1c69433c80a7e818daedf9e5.gif)

算法实现如下：

```cpp
// 一趟划分函数：将区间[s,t]的元素以基准分为左右两部分，返回基准最终位置
int partition(RecType R[], int s, int t) {
    int i = s, j = t;
    RecType base = R[i];  // 以区间第一个元素为基准
    while (i < j) {       // 从两端交替向中间扫描，直到i=j
        // 从右向左找小于基准的元素
        while (j > i && R[j].key >= base.key)
            j--;
        if (i < j) {
            R[i] = R[j];
            i++;
        }
        // 从左向右找大于基准的元素
        while (i < j && R[i].key <= base.key)
            i++;
        if (i < j) {
            R[j] = R[i];
            j--;
        }
    }
    R[i] = base;  // 将基准放入最终的划分位置
    return i;     // 返回基准位置，用于递归划分
}

// 快速排序主函数：递归对R[s..t]区间进行快速排序
void QuickSort(RecType R[], int s, int t) {
    int i;
    if (s < t) {  // 区间内至少有两个元素时才需要划分
        i = partition(R, s, t);       // 一趟划分，得到基准位置i
        QuickSort(R, s, i - 1);       // 递归排序左区间[s, i-1]
        QuickSort(R, i + 1, t);       // 递归排序右区间[i+1, t]
    }
}
```

## 四、选择排序

基本思路是每次都从无序区中选出最小的元素，与无序区的第一个元素进行交换，也就相当于是并入了有序区。
## 1.简单选择排序

![](https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif)

算法实现如下：

```cpp
void SelectSort(RecType R[],int n)
{
    int i,j,k;
    for (i=0;i<n-1;i++)            //做第i趟排序
    {
        k=i;
        for (j=i+1;j<n;j++)        //在当前无序区R[i..n-1]中选key最小的R[k]
        {
            if (R[j].key<R[k].key)
                k=j;               //k记下目前找到的最小关键字所在的位置
        }
        if (k!=i)
            swap(R[i],R[k]);       //R[i]和R[k]两个元素交换
    }
}
```

## 2.堆排序

将排序表中的元素看成是一棵完全二叉树的顺序存储结构。

堆是一棵完全二叉树，如果所有的双亲节点都大于其子孙节点，称为大根堆（反之称为小根堆）

- 对于这样的一棵二叉树，使用大根堆来进行堆排序的过程如下所示：
1. 调整整棵树为大根堆（保证所有的双亲节点都大于子孙节点）
2. 将根元素（一定是此时最大的结点）与排序表中最后面一个元素交换，让最后一个元素浮到堆顶
3. 对得到的新二叉树继续调整为大根堆（忽略上一步沉下去的最大值），得到第k大的结点，与排序表中倒数第k个元素交换
4. 递归执行第3步，直到最后只剩下一个元素，得到排序之后的有序表。

在顺序存储的二叉树中，下标为`n`的结点的孩子节点下标为`2n`,`2n+1`，双亲节点的下标为`n/2`，可以使用这个规律快速访问节点的孩子/双亲。

```text
     1
   /   \
  2     3
 / \   / \
4   5 6   7
```

--- 
![](20260112081115128.jpg)
![](20260112081119021.jpg)

---

## 五、归并排序

- **归并排序**：多次将两个或两个以上的有序表合并成一个新的有序表
- **二路归并排序**：将排序表看做n个长度为1的有序列，然后两两合并，得到（n/2）个长度为2的有序序列，再进行两两合并，得到（n/4）个长度为4的有序序列，...直到得到一个长度为n的有序序列。

![](https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif)

二路归并算法的实现：

- 自底向上的非递归过程：
```cpp
void MergePass(RecType R[],int length,int n)    //对整个排序序列进行一趟归并
{
    int i;
    for (i=0;i+2*length-1<n;i++)                //归并length长的两相邻子表
        Merge(R,i,i+length-1,i+2*length-1);
    if (i+length-1<n-1)                         //余下两个子表，后者的长度小于length
        Merge(R,i,i+length-1,n-1);              //归并这两个子表
}

void MergeSort(RecType R[],int n)               //二路归并排序
{
    int length;
    for (length=1;length<n;length=2*length)     //进行⌈log₂n⌉趟归并
        MergePass(R,length,n);
}

```
- 自顶向下的递归过程
```cpp
void MergeSortDC(RecType R[],int low,int high)  //对R[low..high]进行二路归并排序
{
    int mid;
    if (low<high)
    {
        mid=(low+high)/2;
        MergeSortDC(R,low,mid);
        MergeSortDC(R,mid+1,high);
        Merge(R,low,mid,high);
    }
}

void MergeSort1(RecType R[],int n)              //自顶向下的二路归并算法
{
    MergeSortDC(R,0,n-1);
}
```
## 六、基数排序

基数排序不是根据关键字之间的比较来实现的，而是通过“分配”和“收集”。基数排序按照关键字的各个位依次排序，由每一位的比较顺序不同，分为**最低位优先**和**最高位优先**。实现的原理相同，主要讨论前者。

假设线性表由元素序列$a_0,a_1,\dots,a_{n-1}$构成，每个元素$a_j$的关键字都是一个d元组:
$$
k^{d-1}_j,k^{d-2}_j,\dots,k^{1}_j,k^{0}_j
$$
其中每个k都有r中取值，那么在排序的过程中，使用r个队列$Q_0,Q_1,\dots,Q_{n-1}$进行处理：
- 从低位到高位，依次进行一次分配和收集：
	- 分配：开始时将各队列置空，遍历排序表中的每个元素，根据元素关键字某位上的值插入对应的队列中
	- 收集：将这些队列按照位上的数据从小到大串成一串，得到新的排序表
- 所有的数据位都进行一次分配和收集，最后得到的是一串有序表

--- 
例：对序列(75, 23, 98, 44, 57, 12, 29, 64, 38, 82)进行排序：
解：从低位向高位处理：
- 先看个位，有2, 3, 4, 5, 7, 8, 9这几种,先进行分配：
	- Q2 = (12, 82)
	- Q3 = (23) 
	- Q4 = (44, 64) 
	- Q5 = (75) 
	- Q7 = (57) 
	- Q8 = (98, 38) 
	- Q9 = (29)
- 然后进行回收，得到：(12, 82, 23, 44, 64, 75,  57, 98, 38, 29)
- 再看十位，出现1,2,3,4,5,6,7,8,9这几种，分配如下：
	- Q1 = (12)
	- Q2 = (23, 29)
	- Q3 = (38)
	- Q4 = (44)
	- Q5 = (57)
	- Q6 = (64)
	- Q7 = (75)
	- Q8 = (82)
	- Q9 = (98)
- 进行回收，得到有序序列(12, 23, 29, 38, 44, 57, 64, 75, 82, 98)即为所求
--- 

## 七、各排序算法的比较和选择

上述各种算法的性质特点如下表：

![](20260112081148006.jpg)

按照算法的平均时间，分为以下三类：
1. **平方阶排序**：也称简单排序方法，如直接插入排序、折半插入排序、简单选择排序、冒泡排序
2. **线性对数阶排序**：快速排序、堆排序、二路归并排序
3. **线性阶排序**：基数排序