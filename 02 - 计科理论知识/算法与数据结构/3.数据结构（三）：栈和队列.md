---

---
--- 
> 声明：本篇笔记摘自[《数据结构教程》 - 清华大学出版社](http://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC5%E7%89%88%EF%BC%89/22216268?fromModule=search-result_lemma)，遵循[CC BY 4.0协议](https://creativecommons.org/licenses/by/4.0/legalcode.zh-hans)。
> 存在由AI生成的小部分内容，仅供参考，请仔细甄别可能存在的错误。
--- 
# 一、栈（Stack）
## 1.定义

- **栈**：一种只能在一端进行插入或删除操作的**线性表**
	- **后进先出**（LIFO，last in first out），可以想象成一摞盘子，每次都是拿/放最顶上的一个
- **栈顶**：元素出入的一端
- **栈底**：栈顶的另一端
- **进栈/入栈**：将元素压入（push）栈顶
- **退栈/出栈**：将元素从栈顶弹出（pop）
- 栈也称为**后出先进表**

栈的ADT定义如下：
```ADT Stack
{
	数据对象：
		D = {a[i] | 1<=i<=n, n>=0, a[i]为ElemType类型}
	数据关系：
		R= {<a[i], a[i+a]> | a[i], a[i+1] 属于 D， i = 1， 2， ..., n-1}
	基本运算：
		InitStack(&s)：初始化栈，构造空栈s
		DestoryStack(&s)：销毁栈，释放内存空间
		StackEmpty(s)：判断是否栈空
		Push(&s, e)：将元素e进栈
		Pop(&s, &e)：将栈顶元素弹出，赋值给e
		GetTop(&s, &e)：获取栈顶元素，赋值给e（复制栈顶元素而不是弹出）
}
```

## 2.顺序栈的定义与运算实现

### ① 定义

- 采用顺序存储结构实现的栈称为**顺序栈**
- 使用数组来构造栈的类型：

```cpp
typedef struct {
	ElemType data[MaxSize];    // 存放栈中的数据元素
	int top;                    // 栈顶指针，始终是栈顶元素的索引
} SqStack;                      // 定义顺序栈类型
```

- 栈空：`s->top == -1`
- 栈满：`s->top == MaxSize - 1`
- 进栈操作：
	1. top指针+1
	2. 元素进入 `data[top]`
- 出栈操作
	1. 弹出 `data[top]`
	2. top指针-1
- 注意：top指针始终指向栈顶的位置，只允许操作 `data[top]`， 因此**何时移动top指针至关重要**。

### ② 运算实现

栈的常用操作实现如下：
```cpp
// 顺序栈

#include <iostream>
#include <cstdlib>

#define MaxSize 50
typedef int ElemType;

typedef struct {
	ElemType data[MaxSize];    // 存放栈中的数据元素
	int top;                    // 栈顶指针，始终是栈顶元素的索引
} SqStack;                      // 定义顺序栈类型

// 初始化栈
void InitStack(SqStack *&s) {
    s = (SqStack *)malloc(sizeof(SqStack));
    s->top = -1;
}

// 销毁栈
void DestoryStack(SqStack *&s) {
    free(s);
}

// 判断栈空
bool StackEmpty(SqStack *s) {
    return(s->top == -1);
}

// 进栈
bool Push(SqStack *&s, ElemType e) {
    if (s->top == MaxSize-1) return false;
    s->top++;
    s->data[s->top] = e;
    return true;
}

// 出栈
bool Pop(SqStack *&s, ElemType &e) {
    if (s->top == -1) return false;
    e = s->data[s->top];
    s->top--;
    return true;
}

// 获取栈顶元素
bool GetTop(SqStack *&s, ElemType &e) {
    if (s->top == -1) return false;
    e = s->data[s->top];
    return true;
}

// 测试main函数
int main(void) {
    SqStack *s = NULL;
    InitStack(s);
    printf("判断栈空：%s\n", StackEmpty(s) ? "是" : "否"); 
    int a[5] = {1,2,3,4,5};
    for (auto as : a) {
        Push(s, as);
    }
    printf("判断栈空：%s\n", StackEmpty(s) ? "是" : "否"); 
    int ss;
    GetTop(s, ss);
    printf("栈顶元素为：%d\n", ss);
    for(int i = 0; i < 5; i++) {
        int ss;
        Pop(s, ss);
        printf("%d ", ss);
    }
}
```

### ③ 共享栈

由于数组具有两端，可以考虑将两端同时作为两个存放相同数据类型的栈的栈底，让它们同时向中间扩展，这就是**共享栈**：
```text
--------------------------------------------
 a3 | a2 | a1 |    |    |    |    | b1 | b2 
--------------------------------------------
           ↑                        ↑
       栈1的栈顶指针              栈2的栈顶指针
```

共享栈的数据类型定义如下：

```cpp
typedef struct {
	ElemType data[MaxSize];    // 存放栈中的数据元素
	int top1， top2;           // 两个栈的栈顶指针，始终是各自栈顶元素的索引
} DStack;                      // 定义共享栈类型
```

- 栈空：`top1 == -1 && top2 == MaxSize-1`
- 栈满：`top1 == top2 - 1` （两栈的栈顶元素相遇，数组中所空间都存储了数值）
- 注意进栈和出栈时，栈1和栈2的top指针移动方向是**相反的**
	- 进栈：进栈1则`top1++`，进栈2则`top2--`
	- 出栈：进栈1则`top1--`，进栈2则`top2++`
- 在对共享栈进行操作时，应当添加一个形参指示对哪一个栈进行操作

## 3.链栈的定义与运算实现

### ① 定义

- 相应地，采用链式存储结构实现的栈称为**链栈**
- 使用链表来构造栈的类型（这里使用带头结点的单链表实现）：
```cpp
typedef struct linknode{
	ElemType data;            // 栈元素的数据域
	struct linknode *next;    // 指针域
} LinkStNode;                 // 定义链栈类型
```

- 顺序表/顺序栈是直接定义整个表/栈，而链表/链栈定义的是其中一个结点/栈元素
- 链栈和链表一样，不像顺序表/顺序栈有大小约束。只要内存还有空间就可以一直添加结点或元素

- 栈空：`s->next == NULL`
- 栈满：内存溢出时栈满，可以认为不存在栈满的情况
- 进栈：新建一个结点元素，数据域存放内容，指针域插入到头结点之后
- 出栈：取出首结点，将其删除

### ② 运算实现

链栈的常用运算操作实现如下：
```cpp
    // 链栈
    #include <iostream>
    #include <cstdlib>

    #define MaxSize 50
    typedef int ElemType;

    typedef struct linknode{
        ElemType data;            // 栈元素的数据域
        struct linknode *next;    // 指针域
    } LinkStNode;                 // 定义链栈类型

    // 初始化栈
    void InitStack(LinkStNode *&s) {
        s = (LinkStNode *)malloc(sizeof(LinkStNode));
        s->next = NULL;
    }

    // 销毁栈
    void DestoryStatck(LinkStNode *&s) {
        LinkStNode *pre = s, *p = s->next; // 逐个释放链栈中的所有元素
        while(p != NULL) {
            free(pre);
            pre = p;
            p = pre->next;
        }
        free(pre);
    }

    // 判断是否为空
    bool StackEmpty(LinkStNode *s) {
        return(s->next == NULL);
    }

    // 进栈
    bool Push(LinkStNode *&s, ElemType e) {
        LinkStNode *p;
        p = (LinkStNode *)malloc(sizeof(LinkStNode));
        p->data = e;
        p->next = s->next;
        s->next = p;
        return true;
    }

    // 出栈
    bool Pop(LinkStNode *&s, ElemType &e) {
        LinkStNode *p;
        if (s->next == NULL) return false;
        p = s->next;
        e = p->data;
        s->next = p->next;
        free(p);
        return true;
    }

    // 获取栈顶元素
    bool GetTop(LinkStNode *&s, ElemType &e) {
        if (s->next == NULL) return false;
        e = s->next->data;
        return true;
    }

    // 测试main函数
    int main(void) {
        LinkStNode *s = NULL;
        InitStack(s);
        printf("判断栈空：%s\n", StackEmpty(s) ? "是" : "否"); 
        int a[5] = {1,2,3,4,5};
        for (auto as : a) {
            Push(s, as);
        }
        printf("判断栈空：%s\n", StackEmpty(s) ? "是" : "否"); 
        int ss;
        GetTop(s, ss);
        printf("栈顶元素为：%d\n", ss);
        for(int i = 0; i < 5; i++) {
            int ss;
            Pop(s, ss);
            printf("%d ", ss);
        }
    }
```

## 4.栈的应用

### 1.简单表达式求值

例如，对于 `1 + 2 * 3 - (4 + 2)` 这样的**中缀表达式**，可以使用栈来求值：

- **后缀表达式（逆波兰表达式）**：在算术运算符中，运算符在操作数的后面，越靠前的运算符越先执行。
	- 如：`1 + 2 * 3 -> 1 2 3 * +`
- **前缀表达式**：在算术运算符中，运算符在操作数的前面
	- 如：`1 + 2 * 3 -> + 1 * 2 3`

对于一个中缀表达式，我们通常将其化为后缀表达式，然后通过后缀表达式来计算。这两步都是基于栈实现的。

#### 第一步：中缀转后缀 (Shunting-Yard 算法) -- 对运算符的“重排序”

**规则**：从左向右对表达式中的数值和运算符进行处理：
1. **数字**：直接输出。
2. **左括号 `(`**：直接入栈。
3. **右括号 `)`**：不断出栈并输出，直到遇到 `(`（`(` 出栈但不输出）。
4. **运算符**：（为了保证后缀表达式中优先级高的在前，需要保证优先级高的先出栈）
	-  若当前运算符优先级 **大于** 栈顶运算符，入栈；
	-  否则，将栈中优先级**更高或相等**的运算符全部弹出输出，再将当前运算符入栈。
5. **结束**：最后将栈中的元素依次出栈

实例演示：`3 + (2 + 1) * 5`

|**扫描字符**|**操作**|**符号栈 (Stack)**|**输出队列 (Postfix)**|
|---|---|---|---|
|`3`|输出|`[]`|`3`|
|`+`|入栈|`[+]`|`3`|
|`(`|入栈|`[+, (]`|`3`|
|`2`|输出|`[+, (]`|`3 2`|
|`+`|入栈|`[+, (, +]`|`3 2`|
|`1`|输出|`[+, (, +]`|`3 2 1`|
|`)`|弹出直到 `(`|`[+]`|`3 2 1 +`|
|`*`|入栈 (`*` > `+`)|`[+, *]`|`3 2 1 +`|
|`5`|输出|`[+, *]`|`3 2 1 + 5`|
|结束|清空栈|`[]`|**`3 2 1 + 5 * +`**|

#### 第二步：后缀表达式求值 -- 对操作数的对运算符的“重排序”


**规则：**

1. **数字**：入栈。
2. **运算符**：弹出栈顶的两个数字（先弹出的为右操作数，后弹出的为左操作数），进行运算，将**结果压回栈中**。

实例演示：`3 2 1 + 5 * +`

|**扫描字符**|**操作**|**操作数栈 (Operand Stack)**|**解释**|
|---|---|---|---|
|`3, 2, 1`|入栈|`[3, 2, 1]`|连续三个数字入栈|
|`+`|弹出 `1, 2`|`[3, 3]`|计算 `2 + 1 = 3`，入栈|
|`5`|入栈|`[3, 3, 5]`||
|`*`|弹出 `5, 3`|`[3, 15]`|计算 `3 * 5 = 15`，入栈|
|`+`|弹出 `15, 3`|`[18]`|计算 `3 + 15 = 18`，入栈|

**最终结果：18**

- 在中缀->后缀的处理过程中，相当于是通过栈来把表达式中的运算符按照优先级进行了排序，数值的顺序保持不变。
- 求值的过程中，通过将操作数存储进栈中，实现了按照高优先级到低优先级的分级计算，最后得出累积的结果即为整个表达式的值。
# 二、队列（Queue）

## 1.定义

- **队列**：一种只能在一端插入，另一端删除的**线性表**
	- **先进先出**（FIFO，first in first out），可以想象成火车站安检，人们从安检门的一侧进入，另一侧出来
- **队头**：元素退出的一端
- **队尾**：元素进入的一端
- **进队/入队**：元素从队尾进入队列
- **出队/离队**：元素从队头离开队列
- 栈也称为**先出先进表**

队列的ADT定义如下：
```ADT
{
	数据对象：
		D = {a[i] | 1<=i<=n, n>=0, a[i]为ElemType类型}
	数据关系：
		R= {<a[i], a[i+a]> | a[i], a[i+1] 属于 D， i = 1， 2， ..., n-1}
	基本运算：
		InitQueue(&q)：初始化队列，构造空队列q
		DestoryQueue(&q)：销毁队列，释放内存空间
		QueueEmpty(q)：判断是否为空队列
		enQueue(&q, e)：使元素e进队列
		deQueue(&q, &e)：从队列q中出队一个元素，赋值给e
}
```

## 2.顺序队的定义与基本运算实现

### ① 定义
采用顺序结构存储的队列称为**顺序队**。

顺序队的类型声明如下：
```cpp
typedef struct {
	ElemType data[MaxSize];     // 存放数据元素
	int front, rear;            // 队头指针和队尾指针
} SqQueue;                      // 定义顺序队类型
```

- 队空：`q->front == q->rear`
- 队满：`q->rear == MaxSize-1`
- 进队：先将rear+1,然后新数据在rear处
- 出队：先将front+1，然后取出front处的数据
- 
![](20260109164405037.jpg)
### ② 基本运算实现
```cpp
// 顺序队
#include <iostream>
#include <cstdlib>

#define MaxSize 50
typedef int ElemType;

typedef struct {
	ElemType data[MaxSize];     // 存放数据元素
	int front, rear;            // 队头指针和队尾指针
} SqQueue;                      // 定义顺序队类型

// 初始化队列
void InitiQueue(SqQueue *&q) {
    q = (SqQueue *)malloc(sizeof(SqQueue));
    q->front = q->rear = -1;
}

// 销毁队列
void DestoryQueue(SqQueue *&q) {
    free(q);
}

// 判断是否为空
bool EmptyQueue(SqQueue *q) {
    return (q->front == q->rear);
}

// 进队
bool enQueue(SqQueue *&q, ElemType e) {
    if (q->rear == MaxSize-1) return false;
    q->rear++;
    q->data[q->rear] = e;
    return true;
}

// 出队
bool deQueue(SqQueue *&q, ElemType &e) {
    if (q->front == q->rear) return false;
    q->front++;
    e = q->data[q->front];
    return true;
}

int main(void) {
    SqQueue *q = NULL;
    
    // 1. 初始化队列
    InitiQueue(q);
    printf("队列初始化完成\n");
    
    // 2. 测试队列是否为空
    printf("初始时队列是否为空: %s\n", EmptyQueue(q) ? "是" : "否");
    
    // 3. 测试进队操作
    printf("\n开始进队操作:\n");
    int elements[] = {10, 20, 30, 40, 50};
    for (int i = 0; i < 5; i++) {
        if (enQueue(q, elements[i])) {
            printf("进队元素: %d\n", elements[i]);
        } else {
            printf("进队失败，队列可能已满\n");
        }
    }
    
    // 4. 再次检查队列是否为空
    printf("\n进队后队列是否为空: %s\n", EmptyQueue(q) ? "是" : "否");
    
    // 5. 测试出队操作
    printf("\n开始出队操作:\n");
    ElemType e;
    printf("出队顺序: ");
    while (!EmptyQueue(q)) {
        if (deQueue(q, e)) {
            printf("%d ", e);
        }
    }
    printf("\n");
    
    // 6. 出队后再次检查队列状态
    printf("\n出队后队列是否为空: %s\n", EmptyQueue(q) ? "是" : "否");
    
    // 7. 测试空队列出队
    printf("\n测试空队列出队: ");
    if (!deQueue(q, e)) {
        printf("出队失败，队列为空（正常）\n");
    }
    
    // 8. 测试队列满的情况（可选）
    printf("\n测试队列满的情况:\n");
    for (int i = 0; i < MaxSize + 5; i++) {  // 故意多进队几个
        if (!enQueue(q, i * 10)) {
            printf("队列已满，无法进队元素 %d\n", i * 10);
            break;
        }
    }
    
    // 9. 销毁队列
    DestoryQueue(q);
    printf("\n队列已销毁\n");
    
    return 0;
}
```

对于环形顺序队来说，计算其长度的公式如下：
$$
len=(rear-front+MaxSize)\%Maxsize
$$

## 3.链队的定义与基本运算实现

### ① 定义

采用链式结构存储的队列称为**链队**。

链队中数据结点的类型声明如下：
```cpp
typedef struct qnode{
	ElemType data;               // 数据域
	struct qnode *next;          // 指针域
} DataNode;                      // 数据结点类型定义
```

链队头结点（链队结点）的类型声明如下：
```cpp
typedef struct {
	DataNode *front;          // 指向队首结点
	DataNode *rear;	          // 指向队尾结点
} LinkQuNode;                 // 链队结点类型定义
```

|              | **DataNode (数据结点)**                 | **LinkQuNode (链队结点)**             |
| ------------ | ----------------------------------- | --------------------------------- |
| **存储<br>内容** | 实际的数据元素（`data`）和指向下一个结点的指针（`next`）。 | 两个指针：`front`（指向队头）和 `rear`（指向队尾）。 |
| **存在<br>数量** | 队列中有多少个元素，就有多少个 `DataNode`。         | 整个队列**只有一个**。                     |
| **内存<br>分配** | 每次入队（`enQueue`）时动态申请。               | 仅在初始化（`InitQueue`）时申请一次。          |
| **结点<br>作用** | 构成队列的“身体”                           | 构成队列的“头脑”                         |

- 队空：`q->rear == NULL || q->front == NULL`
- 队满：内存溢出（几乎不会发生，认为不会队满）
- 进队：新建结点e存放数据，插入链队的尾结点
- 出队：取出队首结点的data值，将队首结点删除
![](20260109192537639.jpg)


### ② 基本运算实现

```cpp
// 顺序队
#include <iostream>
#include <cstdlib>

typedef int ElemType;

typedef struct qnode{
	ElemType data;               // 数据域
	struct qnode *next;          // 指针域
} DataNode;                      // 数据结点类型定义

typedef struct {
	DataNode *front;          // 指向队首结点
	DataNode *rear;	          // 指向队尾结点
} LinkQuNode;                 // 链队结点类型定义

// 初始化队列
void InitQueue(LinkQuNode *&q)
{
    q = (LinkQuNode *)malloc(sizeof(LinkQuNode));
    q->front = q->rear = NULL;
}

// 销毁队列
void DestroyQueue(LinkQuNode *&q)
{
    DataNode *pre = q->front, *p;    // pre 指向队首结点
    if (pre != NULL)
    {
        p = pre->next;              // p 指向 pre 结点的后继结点
        while (p != NULL)           // p 不空时循环
        {
            free(pre);              // 释放 pre 结点
            pre = p; p = p->next;   // pre、p 同步后移
        }
        free(pre);                  // 释放最后一个数据结点
    }
    free(q);                        // 释放链队结点
}


// 判断队空
bool QueueEmpty(LinkQuNode *q)
{
    return(q->rear == NULL);
}

// 入队
bool enQueue(LinkQuNode *&q, ElemType e)
{
    DataNode *p;
    p = (DataNode *)malloc(sizeof(DataNode)); // 创建新结点
    p->data = e;
    p->next = NULL;
    if (q->rear == NULL)                      // 若链队空，则新结点既是首结点又是尾结点
        q->front = q->rear = p;
    else                                      // 若链队不空
    {
        q->rear->next = p;                    // 将结点 p 链到队尾，并将 rear 指向它
        q->rear = p;
    }
    return true;
}

// 出队
bool deQueue(LinkQuNode *&q, ElemType &e)
{
    DataNode *t;
    if (q->rear == NULL)                // 原来队列为空
        return false;
    t = q->front;                       // t 指向首结点
    if (q->front == q->rear)            // 原来队列中只有一个数据结点时
        q->front = q->rear = NULL;
    else                                // 原来队列中有两个或两个以上结点时
        q->front = q->front->next;
    e = t->data;
    free(t);
    return true;
}

int main(void) {
    LinkQuNode *q;
    ElemType e;

    // 1. 初始化队列
    printf("1. 初始化队列...\n");
    InitQueue(q);

    // 2. 判空
    if (QueueEmpty(q)) {
        printf("   队列当前为空。\n");
    }

    // 3. 入队操作
    printf("2. 依次将 10, 20, 30 入队...\n");
    enQueue(q, 10);
    enQueue(q, 20);
    enQueue(q, 30);

    // 4. 出队操作
    printf("3. 开始出队：\n");
    while (!QueueEmpty(q)) {
        if (deQueue(q, e)) {
            printf("   出队成功，元素为: %d\n", e);
        }
    }

    // 5. 再次判空
    if (QueueEmpty(q)) {
        printf("4. 所有元素已出队，队列为空。\n");
    }

    // 6. 销毁队列
    printf("5. 销毁队列，释放内存。\n");
    DestroyQueue(q);

    return 0;
}
```
## 4.双端队列

**双端队列**是两端都可以进队/出队的队列，虽然两端分为**前端**和**后端**，但都可以进行数据的出入。

```text
      +-------------------------------+
前 -->                                 <-- 后
端 <--                                 --> 端
      +-------------------------------+
```


双端队列的两端可以进行限制。如果限制元素只能从同一端出入，那么这个队列就变成两个栈底靠在一起的栈了。

# 三、总结：迷宫路径问题的求解

在求解迷宫路径问题时，使用栈和队列均可以得到一条从起点通往终点的路径。

## 2. 基于栈的深度优先搜索 (DFS)

### 核心思想：不撞南墙不回头

栈（Stack）具有**后进先出 (LIFO)** 的特性。当我们在迷宫中每走一步，就将当前坐标压入栈中。

- **过程**：从起点开始，随机选择一个方向（如“下”）一直走下去。
- **遇到死胡同**：从栈顶弹出当前位置（回溯），回到上一个有其他选择的分叉路口。
- **结果**：DFS 像是一个孤独的探险家，总是试图走得“更深”。它找到的路径**不一定是最短路径**，但由于其递归特性，空间开销在某些路径分布下较小。

## 3. 基于队列的广度优先搜索 (BFS)

### 核心思想：层层递进的“地毯式搜索”

队列（Queue）具有**先进先出 (FIFO)** 的特性。我们将起点入队，然后依次处理队首结点。

- **过程**：从起点开始，同时探索所有相邻的通路（第一圈），然后再从这些点出发探索它们的邻居（第二圈）。
- **特点**：像是在迷宫起点倒了一盆水，水流会均匀地向各个方向蔓延。
- **结果**：BFS**一定能找到最短路径**。因为它是一层一层向外扩展的，当第一次接触到终点时，所经过的层数必然最少。