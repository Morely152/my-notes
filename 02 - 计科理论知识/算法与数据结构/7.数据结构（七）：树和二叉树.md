---

---
--- 
> 声明：本篇笔记摘自[《数据结构教程》 - 清华大学出版社](http://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC5%E7%89%88%EF%BC%89/22216268?fromModule=search-result_lemma)，遵循[CC BY 4.0协议](https://creativecommons.org/licenses/by/4.0/legalcode.zh-hans)。
> 存在由AI生成的小部分内容，仅供参考，请仔细甄别可能存在的错误。
--- 

# 一、树的基本概念
## 1.树的定义

- **树**是由n个结点（或元素）组成的有限集合（记作T）
	- 如果n=0，称为**空树**，是树的一个特例
	- 如果n>1，有且仅有一个结点成为**树的根结点**（简称为根），其余结点可分为m个互不相交的有限集$T_1、T_2、 \dots 、T_m$，其中每个子集也符合树的定义，称为T的**子树**
- 包含唯一根结点的树称为**有根树**

树的定义是递归的，刻画了树的固有特性，即一棵大的数是由多个小的子树构成的。

树的ADT定义如下：
```text
ADT Tree {
	数据对象：
		D = { a[i] | 1<=i<=n, n>=0, a[i]为ElemType类型 }
	数据关系：
		R = {<a[i], a[j]> | a[i],a[j]∈D, 1<=i, j<=n, 其中有且仅有一个结点没有前驱结点，其余每个结点只能有一个前驱节
		点，其余每个结点只有一个前驱结点，但可以有零个或多个后继结点}
	基本运算：
		InitTree(&t)：初始化树t，构造一棵空树
		DestoryTree(&t)：销毁树t，释放内存空间
		TreeHeight(t)：求树t的高度
		Parent(t, p)：求树t中p结点的双亲结点
		Brother(t, p)：求树t中p结点所有的兄弟结点
		Sons(t, p)：求树t中p结点所有的子孙结点
		...
}
```
## 2.逻辑表示方法

### ① 树形表示法

用圆圈表示结点，结点之间的关系通过连线表示。连线不标箭头，默认从上到下
![](20260110201908806.jpg)
### ② 文氏图表示法

每棵树对应一个圆圈，通过圈之间的嵌套关系来体现树之间的层级关系
![](20260110201927194.jpg)
### ③ 凹入表示法

每棵树的根结点对应一个条形，类似于文件夹的图示方法
![](20260110201919864.jpg)

### ④ 括号表示法

使用括号的嵌套表示结点之间的关系
```text
A(B,(E,F),C(G(J)),D(H,I(K,L,M)))
```

## 3.基本术语

- **度**
	- 某个结点的子树个数称为该**结点的度**
	- 树中所有结点的度中最大值称为**树的度**
	- 度为k的树称为**k次树**
- **分支结点**与**叶子结点**
	- 度不为0的结点称为**分支结点**（非终端结点），每个结点的分支数就是该结点的度
		- 度为1 -> 单分支结点
		- 度为2 -> 双分支结点
	- 度为0的结点称为**叶子结点**
- **路径**与**路径长度**
	- 若存在连续的结点序列（k1, k2, ..., kn）能够从k1沿着序列到kn，称序列是一条**路径**
	- 序列的长度即为沿路径到达kn通过的结点数减去1
- **孩子结点、双亲结点、兄弟结点、子孙结点、祖先结点**
	- 参考家庭树中，家庭成员之间的关系定义
- **结点层次**和**树的高度**（深度）
	- 结点层次从树根开始定义，**树根为第1层**，往下依次为第2、3、...、n层
	- 树中的最大结点层次称为树的**高度**（深度）
- **有序树**和**无序树**
	- 见名知义，根据树中各结点的子树是否按次序从左向右排列定义
- **森林**
	- m（m>=0）棵互不相交的树构成森林
	- 去掉一棵树的根结点，就形成了森林；将多棵树的根结点连接到一起，森林就成了树

对上述术语的图示如下：
![](20260110204725327.png)
## 4.树的性质

~~(这些公式用来练一下$L^AT_EX$ 挺合适的，反正也记不住，哈哈)~~

1. 树中的结点数等于所有结点的度数之和加一
2. 度为m的树中，第i层上最多有$m^{i-1}$个结点
	- 若一棵树每一层都是满的，称这棵树为**满m次数**
3. 高度为h的m次树最多有$\frac{m^h-1}{m-1}$个结点
4. 具有n个结点的m次树的最小高度为 $\lceil log_m(n(m-1)+1) \rceil$ 

## 5.树的基本运算

### ① 基本运算分类

由于树属于非线性结构，结点之间的关系比线性结构复杂，树的运算会复杂得多。树的运算主要分为以下三类：
1. 结点的查询，如寻找当前节点的兄弟结点等
2. 插入/删除某个结点，如在指定位置插入一个孩子结点
3. 遍历树中的所有结点
### ② 树的遍历

由于树的定义是递归的，对树中的结点的遍历也是递归进行的。对树中的所有子树都按照一定的规则遍历，就完成了对整棵树的遍历。其中根据对子树的结点遍历顺序，分为以下几种遍历方式：
#### a.先根遍历
1. 访问根结点
2. 从左到右**先根遍历**根结点的每一棵子树
#### b.后根遍历
1. 从左到右**后根遍历**根结点的每一棵子树
2. 访问根结点
#### c.层次遍历
从根节点开始遍历树的每一层，从上往下，从左向右

--- 
例：对于图中的树，三种遍历方式得到的结果如下：
![](20260110201908806.jpg)

先根遍历：ABEFCGJDHIKLM
后根遍历：EFBJGCHKLMIDA
层序遍历：ABCDEFGHIJKLM

--- 
## 6.树的存储结构

### ① 双亲存储结构



### ② 孩子链存储结构

### ③ 孩子兄弟链存储结构

# 二、二叉树的概念和性质

## 1.定义

## 2.性质

## 3.二叉树与树、森林之间的转换

# 三、二叉树的存储结构

## 1.顺序存储结构实现

## 2，链式存储结构实现

# 四、二叉树的基本运算及实现

## 1，基本运算概述

## 2.基本运算实现

# 五、二叉树的遍历

## 1.概念

## 2.先序、中序和后序遍历的递归算法

# 六、二叉树的构造

# 七、线索二叉树

## 1.概念

## 2.线索化二叉树

## 3.遍历线索化二叉树

# 八、哈夫曼树

## 1.概述

## 2.哈夫曼树的构造算法

## 3.哈夫曼编码

# 九、用并查集求解等价问题

## 1.并查集的定义

## 2.并查集的算法实现