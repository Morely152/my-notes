---

---
--- 
# 一、线性表及其逻辑结构

## 1.定义

- **线性表**：具有相同特性的数据元素的一个有限序列。
- 线性表的**长度**：线性表中所含元素的个数n。
- 线性表的一般表示方式：($a_1$, $a_2$, ..., $a_n$)
	- 其中$a_1$和$a_n$分别表示表头元素和表尾元素
- 线性表中的元素满足线性关系，即第i个元素在第i+1个元素的前面，第i-1个元素的后面
- 线性表满足以下三个特点：
	- 有穷性：线性表中的元素个数有限
	- 一致性：线性表中的元素性质相同
	- 序列性：所有元素的相对位置是线性的，即存在唯一的开始元素和结束元素
- 线性表中的元素的位置只与序号有关，因此可以存储值重复的元素
## 2.ADT描述

```ADT
ADT List
{
	数据对象：
		D = {ai | 1<=i<=n, n>=0; ai为ElementType类型}
	数据关系：
		R = {<ai, ai+1> | ai, ai+1 属于 D, i=1, 2,..., n-1}
	基本运算：
		InitList(&L)：初始化线性表，构造空线性表L
		DestoryList(&L)：销毁线性表，释放为L创建的内存空间
		ListEmpty(L)：判断L是否为空
		ListLength(L)：求线性表长度
		DispList(L)：输出线性表，当L不为空时顺序输出其中的元素
		GetElem(L, i, &e)：按序号获取线性表中的元素，用e返回L中第i个元素的值
		LocateElem(L, e)：返回L中第一个值与e相等的元素序号
		ListInsert(&L, i, e)：在L的第i个位置插入元素e
		ListDelete(&L, i, &e)：删除L的第i个元素，并且用e返回元素值
}
```

为了实现对顺序表的修改和参数的输出，基本运算中的参数有一些带有&，表示是引用参数。
# 二、线性表的顺序存储结构

## 1.顺序表

线性表的顺序存储，即将线性表的元素按照逻辑顺序，依次存储到一块连续的内存中。
线性表的顺序存储结构简称为**顺序表**。

顺序表的结构体类型如下：
```c++
#define MaxSize 50

typedef struct {
	ElementType data[MaxSize];
	int length;
} SqList;
```

## 2.基本运算实现

```cpp
#include <iostream>
#include <cstdlib>

#define MaxSize 50
typedef int ElemType;

typedef struct {   // 包含一个长度为MaxSize的数组和一个length变量记录长度
	ElemType data[MaxSize];
	int length;
} SqList;

// 建立顺序表
void CreateList(SqList *&L, ElemType a[], int n) {
    int i = 0, k = 0;
	L = (SqList *)malloc(sizeof(SqList));  // 分配SqList所需大小的内存空间给指针L
	while (i < n) {                  // 存储a[]中的前n个元素
		L->data[k] = a[i];
		k++;i++;
	}
	L->length = k;
}


// 初始化顺序表
void InitList(SqList *&L) {
	L = (SqList *)malloc(sizeof(SqList));
	L->length = 0;
}

// 销毁线性表
void DestoryList(SqList *&L) {
	free(L);
}

// 判断表空
bool ListEmpty(SqList *L) {
	return(L->length==0);
}

// 求线性表的长度
int ListLength(SqList *L) {
	return(L->length);
}

// 输出线性表
void DispList(SqList *L) {
	for (int i = 0; i < L->length; i++) {
		printf("%d ", L->data[i]);
	}
	printf("\n");
}

// 按序号求线性表中的元素
bool GetElem(SqList *L, int i, ElemType &e) {
	if (i < 1 || i > L -> length) {
		return false;
	}
	e = L -> data[i-1];
	return true;
}

// 按元素值查找
int LocateElem(SqList *L, ElemType e) {
	int i = 0;
	while (i < L->length && L->data[i] != e) {
		i++;
	}
	if (i >= L->length) {
		return 0;
	} else {
		return i+1;
	} 
}

// 插入数据元素
bool ListInsert(SqList *&L, int i, ElemType e) {
    int j;
	if (i < 1 || i > L->length + 1 || L->length == MaxSize) {
		return false;
	}
	i--;
	for(j=L->length;j>i;j--) {
		L ->data[j] = L -> data[j-1];
	}
	L->data[i] = e;
	L -> length++;
	return true;
}

// 删除数据元素
bool ListDelete(SqList *&L, int i, ElemType &e) {
    int j;
	if (i < 1 || i > L->length + 1 || L->length == MaxSize) {
		return false;
	}
	i--;
	e = L ->data[i];
	for(j=i; j<L->length-1; j++) {
		L ->data[j] = L -> data[j+1];
	}
	L -> length--;
	return true;
}


int main() {
    SqList *L = NULL;
    ElemType a[] = {1, 2, 3, 4, 5};
    int n = sizeof(a) / sizeof(a[0]);
    ElemType e;
    bool res;

    // 1. 测试创建顺序表
    printf("1. 创建顺序表，初始元素：");
    CreateList(L, a, n);
    DispList(L);  // 输出：1 2 3 4 5

    // 2. 测试表长度
    printf("2. 顺序表长度：%d\n", ListLength(L));  // 输出：5

    // 3. 测试判断表空
    printf("3. 顺序表是否为空：%s\n", ListEmpty(L) ? "是" : "否");  // 输出：否

    // 4. 测试按序号查找元素
    res = GetElem(L, 3, e);
    if (res) {
        printf("4. 查找第3个元素：%d\n", e);  // 输出：3
    } else {
        printf("4. 查找第3个元素：失败\n");
    }

    // 5. 测试按值查找元素
    int pos = LocateElem(L, 4);
    if (pos != 0) {
        printf("5. 查找元素4的位置：第%d个\n", pos);  // 输出：第4个
    } else {
        printf("5. 查找元素4：未找到\n");
    }

    // 6. 测试插入元素
    res = ListInsert(L, 2, 99);
    if (res) {
        printf("6. 在第2个位置插入99后，顺序表：");
        DispList(L);  // 输出：1 99 2 3 4 5
    } else {
        printf("6. 插入元素失败\n");
    }

    // 7. 测试删除元素
    res = ListDelete(L, 4, e);
    if (res) {
        printf("7. 删除第4个元素，被删除的元素：%d，删除后顺序表：", e);
        DispList(L);  // 输出：1 99 2 4 5
    } else {
        printf("7. 删除元素失败\n");
    }

    // 8. 测试初始化空表
    SqList *L2 = NULL;
    InitList(L2);
    printf("8. 初始化空表，是否为空：%s\n", ListEmpty(L2) ? "是" : "否");  // 输出：是

    // 9. 销毁顺序表
    DestoryList(L);
    DestoryList(L2);
    printf("9. 顺序表已销毁\n");

    return 0;
}
```

- `*L` 与 `*&L` 的区别：
	- `*L` 是指针的值传递，只能修改指针指向的**数据内容**，不能改指针本身的指向；
	- `*&L` 是指针的引用传递，既能改数据内容，也能改指针的指向；
- 选择原则：仅操作表内容用 `*L`，需要给指针分配/释放内存、改指向时用 `*&L`（避免无意义的引用传递，减少风险）。

- 建立线性表的过程：
	- 先在main函数中通过 `SqList *L = NULL;` 新建一个空的指针
	- 然后调用创建线性表的方法，核心操作为 `L = (SqList *)malloc(sizeof(SqList));`，给L分配内存空间

# 三、线性表的链式存储结构

## 1.链表

- 线性表的链式存储结构称为**链表**。
- 线性表的每个元素采用一个**内存结点**存储
	- 每个内存结点包含元素的数据信息（**数据域**）和元素之间的逻辑关系（**指针域**）
- **单链表**：只设置一个指针域，指向后继节点
- **双链表**：设置两个指针域，分别指向前驱节点和后继节点
- **头指针**：每个链表带有一个头结点，头结点的指针（**头指针**）唯一标识该链表
- **首指针、尾指针**：指向链表首结点和尾结点的指针
![](20260108162843517.jpg)

与顺序表相比，链表进行插入和删除的操作比较方便，只需修改指针域即可；
但是链表不具有随机存取性，查找第i个元素的处理比顺序表要复杂一些。

由于指针域的存在，链表的**存储密度**（节点中数据域的空间占用/整个节点的空间占用）低于顺序表。
## 2.单链表

#### ① 相关概念

单链表的结点 `LinkNode` 的类型声明如下：
```cpp
typedef struct LNode {
	ElemType data;
	struct LNode *next;
} LinkNode;
```

这里的 `LNode` 是 `struct LNode` 这个结构体的**标签名（tag name）**，可以把它理解成这个结构体的 “小名”，核心作用是：

- 在结构体内部定义 `next` 指针时，需要用 `struct LNode *next` 来声明 “指向同类型结构体的指针”（因为此时 `LinkNode` 还没完全定义好，只能用 `struct LNode`）；
- 结合前面的 `typedef`，最终把 `struct LNode` 这个复杂的类型名，简化成了 `LinkNode`（可以把 `LinkNode` 看作 “大名”）。

等价于分两步来写：

```cpp
struct LNode {   // 定义一个名为 LNode 的结构体
	ElemType data;
	struct LNode *next;
};

typedef struct LNode LinkNode;  // 把 struct LNode 这个类型，重命名为 LinkNode
```

在算法设计中，多使用带头结点的单链表。在单链表中添加头结点比较方便：
- 单链表的首结点插入与删除的处理，和对其他结点的处理方法一致
- 无论单链表是否为空，都有一个头结点，因此无需额外处理空表

#### ② 单链表的操作



## 3.双链表
# 四、线性表的应用


# 五、有序表

## 1.ADT描述

## 2.存储结构及基本运算算法

## 3.有序表的归并算法

## 4.有序表的应用
