---

---
--- 
> 声明：本篇笔记摘自[《数据结构教程》 - 清华大学出版社](http://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC5%E7%89%88%EF%BC%89/22216268?fromModule=search-result_lemma)，遵循[CC BY 4.0协议](https://creativecommons.org/licenses/by/4.0/legalcode.zh-hans)。
> 存在由AI生成的小部分内容，仅供参考，请仔细甄别可能存在的错误。
--- 

# 一、树的基本概念
## 1.树的定义

- **树**是由n个结点（或元素）组成的有限集合（记作T）
	- 如果n=0，称为**空树**，是树的一个特例
	- 如果n>1，有且仅有一个结点成为**树的根结点**（简称为根），其余结点可分为m个互不相交的有限集$T_1、T_2、 \dots 、T_m$，其中每个子集也符合树的定义，称为T的**子树**
- 包含唯一根结点的树称为**有根树**

树的定义是递归的，刻画了树的固有特性，即一棵大的数是由多个小的子树构成的。

树的ADT定义如下：
```text
ADT Tree {
	数据对象：
		D = { a[i] | 1<=i<=n, n>=0, a[i]为ElemType类型 }
	数据关系：
		R = {<a[i], a[j]> | a[i],a[j]∈D, 1<=i, j<=n, 其中有且仅有一个结点没有前驱结点，其余每个结点只能有一个前驱节
		点，其余每个结点只有一个前驱结点，但可以有零个或多个后继结点}
	基本运算：
		InitTree(&t)：初始化树t，构造一棵空树
		DestoryTree(&t)：销毁树t，释放内存空间
		TreeHeight(t)：求树t的高度
		Parent(t, p)：求树t中p结点的双亲结点
		Brother(t, p)：求树t中p结点所有的兄弟结点
		Sons(t, p)：求树t中p结点所有的子孙结点
		...
}
```
## 2.逻辑表示方法

### ① 树形表示法

用圆圈表示结点，结点之间的关系通过连线表示。连线不标箭头，默认从上到下
![](20260110201908806.jpg)
### ② 文氏图表示法

每棵树对应一个圆圈，通过圈之间的嵌套关系来体现树之间的层级关系
![](20260110201927194.jpg)
### ③ 凹入表示法

每棵树的根结点对应一个条形，类似于文件夹的图示方法
![](20260110201919864.jpg)

### ④ 括号表示法

使用括号的嵌套表示结点之间的关系
```text
A(B,(E,F),C(G(J)),D(H,I(K,L,M)))
```

## 3.基本术语

- **度**
	- 某个结点的子树个数称为该**结点的度**
	- 树中所有结点的度中最大值称为**树的度**
	- 度为k的树称为**k次树**
- **分支结点**与**叶子结点**
	- 度不为0的结点称为**分支结点**（非终端结点），每个结点的分支数就是该结点的度
		- 度为1 -> 单分支结点
		- 度为2 -> 双分支结点
	- 度为0的结点称为**叶子结点**
- **路径**与**路径长度**
	- 若存在连续的结点序列（k1, k2, ..., kn）能够从k1沿着序列到kn，称序列是一条**路径**
	- 序列的长度即为沿路径到达kn通过的结点数减去1
- **孩子结点、双亲结点、兄弟结点、子孙结点、祖先结点**
	- 参考家庭树中，家庭成员之间的关系定义
- **结点层次**和**树的高度**（深度）
	- 结点层次从树根开始定义，**树根为第1层**，往下依次为第2、3、...、n层
	- 树中的最大结点层次称为树的**高度**（深度）
- **有序树**和**无序树**
	- 见名知义，根据树中各结点的子树是否按次序从左向右排列定义
- **森林**
	- m（m>=0）棵互不相交的树构成森林
	- 去掉一棵树的根结点，就形成了森林；将多棵树的根结点连接到一起，森林就成了树

对上述术语的图示如下：
![](20260110204725327.png)
## 4.树的性质

~~(这些公式用来练一下$L^AT_EX$ 挺合适的，反正也记不住，哈哈)~~

1. 树中的结点数等于所有结点的度数之和加一
2. 度为m的树中，第i层上最多有$m^{i-1}$个结点
	- 若一棵树每一层都是满的，称这棵树为**满m次数**
3. 高度为h的m次树最多有$\frac{m^h-1}{m-1}$个结点
4. 具有n个结点的m次树的最小高度为 $\lceil log_m(n(m-1)+1) \rceil$ 

## 5.树的基本运算

### ① 基本运算分类

由于树属于非线性结构，结点之间的关系比线性结构复杂，树的运算会复杂得多。树的运算主要分为以下三类：
1. 结点的查询，如寻找当前结点的兄弟结点等
2. 插入/删除某个结点，如在指定位置插入一个孩子结点
3. 遍历树中的所有结点
### ② 树的遍历

由于树的定义是递归的，对树中的结点的遍历也是递归进行的。对树中的所有子树都按照一定的规则遍历，就完成了对整棵树的遍历。其中根据对子树的结点遍历顺序，分为以下几种遍历方式：
#### a.先根遍历
1. 访问根结点
2. 从左到右**先根遍历**根结点的每一棵子树
#### b.后根遍历
1. 从左到右**后根遍历**根结点的每一棵子树
2. 访问根结点
#### c.层次遍历
从根结点开始遍历树的每一层，从上往下，从左向右

--- 
例：对于图中的树，三种遍历方式得到的结果如下：
![](20260110201908806.jpg)

先根遍历：ABEFCGJDHIKLM
后根遍历：EFBJGCHKLMIDA
层序遍历：ABCDEFGHIJKLM

--- 
## 6.树的存储结构

### ① 双亲存储结构

这是一种顺序存储结构，由于每个结点的双亲结点是唯一的，使用了一个指向双亲结点下标的伪指针，来确定结点在树中的位置。类型声明如下：
```cpp
typedef struct {
	ElemType data;
	int parent;
}PTree[MaxSize];
```

采用这种存储方式，寻找一个结点的双亲结点很方便，但是寻找孩子结点需要遍历整个树。
### ② 孩子链存储结构

链式存储结构，每个结点包含结点值和指向所有孩子结点的指针。类型声明如下：
```cpp
typedef struct node {
	ElemType data;
	struct node * sons[MaxSize];
} TSonNode;
```

采用这种存储方式，寻找一个结点的孩子结点很方便，但是寻找双亲结点需要遍历整个树。
当树的度很大时，会存在较多的空指针，比较浪费存储空间。
### ③ 孩子兄弟链存储结构

链式存储结构，每个结点设计三个域：
- 数据元素域
- 指向左边第一个孩子结点的指针域
- 指向下一个兄弟结点的指针域

类型声明如下：
```cpp
typedef struct tnode{
	ElemType data;
	struct tnode *hp;
	struct tnode *vp;
} TSBNode;
```

对照下图孩子兄弟树的存储关系，可以发现这样的存储结构实际上是将树转换成了一棵**二叉树**进行存储。同样，这种存储结构在查找双亲结点时比较麻烦，需要遍历整棵树。

![](20260110214042375.jpg)

--- 
例：以孩子链作为树的存储结构，设计一个求树t高度的算法。

设树t的高度为 `f(t)`，递归模型如下：
```text
f(t) = 0                   // 若t=NULL
f(t) = MAX{f(p)} + 1       // 其他情况，其中p指向t的孩子
```

整体思路：对t的每个结点查看其孩子结点，直到孩子结点为NULL（叶子结点），然后看叶子结点的高度，取其中最大的即为整棵树的高度。

```cpp
int TreeHeight(TSonNode *t) {
	TSonNode *p；
	int i,h,maxh=0;
	if(t == NULL) {
		return 0;
	} else {
		for(int i = 0; i < MaxSons; i++) {
			p = (t->sons[i]) {
				if (p!=NULL) {
					h=TreeHeight(p);   // 递归调用求树高的方法
					if(maxh < h) maxh = h;
				}
			}
		}
		return(maxh+1);
	}
}
```

--- 

# 二、二叉树的概念和性质

## 1.定义

### ① 基本概念

- **二叉树**：是一个有限的结点集合，此集合或者为空，或者由一个根结点和两棵互不相交的**左子树**和**右子树**的二叉树构成。

二叉树和度为2的树有如下区别：
- 度为2的树中至少要有一个度为2的结点，二叉树无此要求
- 度为2的树不分左右子树，而二叉树中有严格区分


### ② 二叉树的形态

- 空二叉树，没有任何结点
- 单个结点的二叉树：只有一个根结点
- 右子树为空的二叉树：只有左子树
- 左子树为空的二叉树：只有右子树
- 左、右都不空的二叉树

### ③ 满二叉树

- **满二叉树**：所有结点都有左右孩子结点，并且叶子结点都集中在最下面一层
- **层序编号**：从树根（第1层）开始，自上而下、从左往右给二叉树的结点编号

### ④ 完全二叉树

- **完全二叉树**：二叉树中只有最下面两层的结点度数小于2，且最下面一层的叶子结点都在最左边的位置上
	- 说人话：只允许最底下两层缺左/右孩子，并且最底下一层的叶子结点全部“左对齐”
- **层序编号**：从树根（第1层）开始，自上而下、从左往右给二叉树的结点编号

--- 
下图展示了满二叉树和完全二叉树，以及它们的层序编号：
![](20260110233500539.jpg)
满二叉树是完全二叉树的一种特例。

--- 
## 3.二叉树与树、森林之间的转换

- 任何一棵树或者森林都可以唯一对应一棵二叉树
- 任何一棵二叉树也可以唯一地对应一棵树或者森林

### ① 森林/树转换成二叉树

- 一棵树 --> 二叉树：
	- 将树中的所有相邻兄弟之间加一条连线
	- 对每个结点，只保留对长子的连线，删除对其他孩子的连线
	- 将树沿根结点顺时针旋转45度，得到一棵二叉树

![](20260110234723501.jpg)

- 森林 ---> 二叉树：
	- 将森林中的每棵树转换成二叉树
	- 第一棵二叉树不变
	- 从第二棵二叉树开始，将其根结点作为前一棵树根结点的右孩子连接在一起
	- 将所有的二叉树连在一起之后，得到的就是森林转换成的二叉树

![](20260110234954737.jpg)

### ② 二叉树转换成树/森林

- 二叉树 --> 一棵树：
	- 对所有的左孩子，将它的右孩子、它的右孩子的右孩子、…都与它的双亲结点连接起来
	  ![](20260111000547499.jpg)
	- 删除原来左孩子与右孩子以及右孩子和右子孙之间的连线，整理成普通的树
	- 
![](20260111000816712.jpg)

- 二叉树 -> 森林
- 若一棵二叉树由m棵树的森林转化而来，那么它一定有m-1个右孩子/右子孙
	- 拆散根结点与每个右下孩子之间的连线，每个孩子结点都作为一棵新二叉树的根结点
	- 然后将每棵二叉树转换成普通的树

![](20260111001048297.jpg)

### ③ 对二叉树中的结点关系总结

综合上面的二叉树与普通树/森林的转换过程，我们可以认为：

> **对于二叉树中的结点，其左孩子对应普通树的孩子结点，右孩子对应普通树的兄弟结点。**（“左孩右兄”）

# 三、二叉树的存储结构

与线性表类似，二叉树也可以使用线性存储结构和链式存储结构。

## 1.顺序存储结构实现

- 对于一棵二叉树，先给它添加一些虚结点，构成一棵完全二叉树
- 然后进行层序编号，每个结点序号的值就是这个结点在存储空间中的下标
- 添加的虚结点，保留默认值 `NULL` 即可，表中记作 `#`
![](20260111003229081.png)

顺序存储的类型声明如下：

`typedef ElemType SqBinTree[MaxSIze]`

为方便运算，一般将下标为0的第一个元素置空，从第二个元素（下标为1）开始存储。

这样存储一棵结点较为饱满的树比较合适，查找结点以及孩子、双亲结点都比较方便。但如果一棵树只有左单支或者右单支，就需要添加很多虚结点来“撑开”这棵完全二叉树（右单支树的情况下，甚至填充成了满二叉树），浪费了相当多的辅助空间来进行存储。在数据结构中，顺序存储通常只建议用于**满二叉树**或**完全二叉树**。

> 个人觉得这样存储与哈希有类似之处，都是通过值来算出位置，定位和查询很方便，但是存储空间的利用率比较低。
## 2.链式存储结构实现

通常使用一个单链表来存储二叉树。其中结点的存储结构如下：

```text
+--------+------+--------+
| lchild | data | rchild |
+--------+------+--------+
```

- data：数据域
- lchild：指向左孩子的指针
- rchild：指向右孩子的指针

这样的链式存储结构称为**二叉链**。

二叉链中的结点数据类型声明如下：
```cpp
typedef struct node{
	ElemType data;
	struct node *lchild;
	struct node *rchild;
} BTNode;
```

使用二叉链存储的二叉树，在访问孩子结点时很方便，但是访问双亲结点需要遍历整棵树。有时候为了方便，会将指向双亲结点的 `parent` 指针域也添加到结点的数据类型声明中构成**三叉链表**（双链表），以实现快速访问双亲结点。
# 四、二叉树的基本运算及实现

为方便描述，使用前文提到的**二叉链**存储二叉树。规定ElemType为 `char` 型，且二叉树中的数据不重复。
## 1，基本运算概述

- `CreateBTree(&b, str)`：根据使用括号表示法的字符串str创建二叉树b
- `DestortBTree(&b)`：销毁二叉树b，释放存储空间
- `FindNode(b, x)`：在二叉树b中查找结点x
- `LchildNode(p)`、`RchildNode(p)`：找到结点p的左、右孩子
- `BTHeight(b)`：求二叉树b的高度
- `DispBTree(b)`：以括号表示法输出二叉树b
## 2.基本运算实现

### ① 创建二叉树: `CreateBTree(*b, *str)` 

用 `ch` 遍历采用括号表示法表示的二叉树字符串 `str` ，其中只有 4 类字符，其处理方式如下：

- 若 `ch = '('`，表示前面刚创建的结点存在孩子结点，需要将其进栈，以便建立它和它的孩子结点之间的关系（如果一个结点刚创建完毕，其后一个字符不是 `'('`，表示该结点是叶子结点，不需要进栈）。然后开始处理该结点的左孩子，置 $k=1$（表示其后创建的结点将作为当前栈顶结点的左孩子结点）。
- 若 `ch = ')'`，表示以栈顶结点为根结点的子树创建完毕，将其退栈
- 若 `ch = ','`，表示开始处理栈顶结点的右孩子结点，置 $k=2$（表示其后创建的结点将作为当前栈顶结点的右孩子结点）
- 其他情况：只能是单个字符，对应二叉树中的某个结点值，需要创建一个结点存放该结点值。根据值建立它与栈顶结点之间的联系。当 $k=1$ 时，将结点作为栈顶结点的左孩子；当 $k=2$ 时，将结点作为栈顶结点的右孩子

如此循环，直到 `str` 遍历完毕。在算法中使用一个栈保存双亲结点，为了简单用数组 `St` 表示栈，`top` 为栈顶指针，`k` 指定其后处理的结点是双亲结点（栈顶结点）的左孩子（$k=1$）还是右孩子（$k=2$）。

对应的算法实现如下：
``` cpp
#include "htree.h"  //包含二叉树的存储结构声明 

void CreateBTree(BTNode * &b, char *str)
{
    BTNode *St[MaxSize], *p; //St数组作为顺序栈 [cite: 1, 2]
    int top = -1, k, j = 0;   //top为栈顶指针 [cite: 2]
    char ch;
    b = NULL;                //初始时二叉链为空 [cite: 2]
    ch = str[j];
    while (ch != '\0')       //遍历 str中的每个字符 [cite: 2]
    {
        switch(ch)
        {
            case '(': top++; St[top] = p; k = 1; break; //开始处理左孩子结点 
            case ',': k = 2; break;                    //开始处理右孩子结点 
            case ')': top--; break;                    //栈顶结点的子树处理完毕 
            default: 
                p = (BTNode *)malloc(sizeof(BTNode)); //创建一个结点,由p指向它 
                p->data = ch;                          //存放结点值 
                p->lchild = p->rchild = NULL;          //左、右指针都设置为空 
                if (b == NULL)                         //若尚未建立根结点 
                    b = p;                             //p所指结点作为根结点 
                else                                   //已建立二叉树根结点 
                {
                    switch(k)
                    {
                        case 1: St[top]->lchild = p; break; //新建结点作为栈顶结点的左孩子 
                        case 2: St[top]->rchild = p; break; //新建结点作为栈顶结点的右孩子 
                    }
                }
        }
        j++;
        ch = str[j]; //继续遍历 str 
    }
}
```

--- 
例如，对于括号表示的字符串 `“A(B(D(,G)), C(E,F))”`，建立二叉树链式存储结构的过程如下表所示：

| **ch**   | **算法执行的操作**                   | **St 中的元素（栈底 → 栈顶）** |
| -------- | ----------------------------- | -------------------- |
| A        | 建立 A 结点，b 指向该结点               | 空                    |
| (        | A 结点进栈，置 $k=1$                | A                    |
| B        | 建立 B 结点，因 $k=1$ 将其作为 A 结点的左孩子 | A                    |
| (        | B 结点进栈，置 $k=1$                | AB                   |
| D        | 建立 D 结点，因 $k=1$，将其作为 B 结点的左孩子 | AB                   |
| (        | D 结点进栈，置 $k=1$                | ABD                  |
| ,        | 置 $k=2$                       | ABD                  |
| G        | 建立 G 结点，因 $k=2$ 将其作为 D 结点的右孩子 | ABD                  |
| )        | 退栈一次                          | AB                   |
| )        | 退栈一次                          | A                    |
| ,        | 置 $k=2$                       | A                    |
| C        | 建立 C 结点，因 $k=2$ 将其作为 A 结点的右孩子 | A                    |
| (        | C 结点进栈，置 $k=1$                | AC                   |
| E        | 建立 E 结点，因 $k=1$，将其作为 C 结点的左孩子 | AC                   |
| ,        | 置 $k=2$                       | AC                   |
| F        | 建立 F 结点，因 $k=2$，将其作为 C 结点的右孩子 | AC                   |
| )        | 退栈一次                          | A                    |
| )        | 退栈一次                          | 空                    |
| str 遍历完毕 | 算法结束                          |                      |

---
### ② 销毁二叉树: `DestroyBTree(&b)`

设 $f(b)$ 的功能是释放为二叉树 $b$ 中的所有结点分配的空间。其递归模型如下：
```text
若b=NULL: f(b) = 不做任何事情 // 如果b的孩子结点都销毁了就不用处理，b在处理其双亲结点时进行销毁 
其他情况 ：f(b)  f(b->lchild); f(b->rchild); 释放b所指的结点
```

对应的递归算法如下：
```cpp
void DestroyBTree(BTNode * &b)
{
    if (b != NULL)
    {
        DestroyBTree(b->lchild);
        DestroyBTree(b->rchild);
        free(b);
    }
}
```
### ③ 查找结点: `FindNode(b, x)` 

设 $f(b,x)$ 的功能是在二叉树 $b$ 中查找值为 $x$ 的结点，找到后返回其地址，否则返回 NULL。其递归模型如下：

- $f(b,x) = \text{NULL}$                         若 $b == \text{NULL}$
- $f(b,x) = b$                                若 $b \rightarrow \text{data} == x$
- $f(b,x) = p$                                若在左子树中找到了，即 $p = f(b \rightarrow \text{lchild}, x)$ 且 $p \neq \text{NULL}$
- $f(b,x) = f(b \rightarrow \text{rchild}, x)$              其他情况

对应的递归算法如下：
```cpp
BTNode * FindNode(BTNode * b, ElemType x)
{
    BTNode *p;
    if (b == NULL)
        return NULL;
    else if (b->data == x)
        return b;
    else
    {
        p = FindNode(b->lchild, x);
        if (p != NULL)
            return p;
        else
            return FindNode(b->rchild, x);
    }
}
```
### ④ 找孩子结点: `LchildNode(p)` 和 `RchildNode(p)` 

用于直接返回结点的左孩子或右孩子结点地址。算法如下：

```cpp
BTNode * LchildNode(BTNode * p)
{
    return p->lchild; //返回结点p的左孩子结点地址 
}

BTNode * RchildNode(BTNode * p)
{
    return p->rchild; //返回结点p的右孩子结点地址 
}
```
### ⑤ 求高度: `BTHeight(b)`

递归模型如下：

- $f(b) = 0$                                                    若 $b = \text{NULL}$
- $f(b) = \text{MAX}(f(b \rightarrow \text{lchild}), f(b \rightarrow \text{rchild})) + 1$     其他情况 

对应的递归算法实现：
```cpp
int BTHeight(BTNode * b)
{
    int lchildh, rchildh;
    if (b == NULL) return(0); //空树的高度为0 
    else
    {
        lchildh = BTHeight(b->lchild); //求左子树的高度为lchildh 
        rchildh = BTHeight(b->rchild); //求右子树的高度为rchildh 
        return (lchildh > rchildh) ? (lchildh + 1) : (rchildh + 1);
    }
}
```
### ⑥ 输出二叉树: `DispBTree(b)`

其过程是：

- 对于非空二叉树 $b$，先输出结点的结点值
- 当它存在左孩子或右孩子时
	- 输出一个“(”符号
	- 然后递归输出左子树
- 当存在右孩子时
	- 输出一个“,”符号
	- 再递归输出右子树
- 最后输出一个“)”符号

对应的递归算法如下：

```cpp
void DispBTree(BTNode * b)
{
    if (b != NULL)
    {
        printf("%c", b->data);
        if (b->lchild != NULL || b->rchild != NULL)
        {
            printf("(");           //有孩子结点时才输出“(” 
            DispBTree(b->lchild);  //递归输出左子树 
            if (b->rchild != NULL) printf(","); //有右孩子结点时才输出“,” 
            DispBTree(b->rchild);  //递归输出右子树 
            printf(")");           //有孩子结点时才输出“)” 
        }
    }
}
```
# 五、二叉树的遍历

## 1.概念

**二叉树遍历**是指按照一定的次序访问二叉树中的所有结点，并且每个结点只访问一次。这是二叉树最基本的操作，是完成其他运算的基础。

### ① 先序遍历：**树根** -> 左子树 -> 右子树

- 访问根结点
- **先序遍历访问**访问左子树
- **先序遍历访问**访问右子树
### ② 中序遍历：左子树 -> **树根** -> 右子树

- **中序遍历访问**访问左子树
- 访问根结点
- **中序遍历访问**访问右子树
### ① 后序遍历：左子树 -> 右子树 -> **树根**

- **后序遍历访问**访问左子树
- **后序遍历访问**访问右子树
- 访问根结点

---
例：对下图的二叉树，上面三种遍历方法得到的结果如下：
```text
    A
   / \
  B   C
 /   / \
D   E   F
 \ 
  G
```

- 先序遍历：**A**BDGCEF（树根在前）
- 中序遍历：DGB**A**ECF（树根在中）
- 后序遍历：GDBEFC**A**（树根在后）

可以看到，无论是哪种方法，对兄弟结点的遍历始终是从左向右的。采用什么顺序遍历，根结点的位置就在哪里。

---
## 2.先序、中序和后序遍历的递归算法

```cpp
// 先序遍历
void PreOrder(BTNode *b) {
	if (b != NULL) {
		printf("%c", b->data);
		PreOrder(b->lchild);
		PreOrder(b->rchild);
	}
}

// 中序遍历
void InOrder(BTNode *b) {
	if (b != NULL) {
		InOrder(b->lchild);
		printf("%c", b->data);
		InOrder(b->rchild);
	}
}

// 后序遍历
void PostOrder(BTNode *b) {
	if (b != NULL) {
		PostOrder(b->lchild);
		PostOrder(b->rchild);
		printf("%c", b->data);
	}
}
```

将输出结点数据域的操作改成其他的操作，就可以得到二叉树的一些基本运算算法。如计算二叉树的结点个数：

```cpp
int CntNode(BTNode *b) {
	if (b == NULL) {
		return 0;
	} else {
		return CntNode(b->lchild) + CntNode(b->rchild) + 1;
	}
}
```

# 六、二叉树的构造

给定一棵二叉树的先序/中序/后续遍历结果，并不能唯一确定这棵二叉树。虽然对一棵二叉树来说，它本身的遍历结果是唯一的，但是有些二叉树可能有相同的遍历结果。

**定理1：任何n（n>=0）个不同结点的二叉树，都可以由它的中序序列和先序序列唯一确定。**
**定理2：任何n（n>=0）个不同结点的二叉树，都可以由它的中序序列和后序序列唯一确定。**
（也就是说，至少要知道中序序列和其余一种才能唯一确定一棵二叉树，先序+后序也不能唯一确定）。

确定一棵二叉树的步骤：
- 根据先序/后序序列，确定二叉树的根结点（先序看第一个，后序看最后一个）
- 结合中序序列，根结点左边的是左子树，右边的是右子树
- 回到先序/后序序列中，根据上一步划分的左/右子树，回到第一步找出子树的根结点，然后再通过中序序列判断左右子树各自的左右子树
- 递归进行下去，直到找到所有的叶子结点，就完成了二叉树的构造。

--- 
例：对于前例的二叉树，有如下序列：

- 先序序列：**A**BDGCEF
- 中序序列：DGB**A**ECF

- 通过先序序列找到树根为A，通过中序序列，划分得到左子树DGB，右子树ECF
- 对于左子树DGB:
	- 通过先序序列找到树根是B，通过中序序列，划分得到左子树是DG，右子树为空
	- 对于左子树DG：
		- 通过先序序列找到树根是D，通过中序序列，划分得到左子树为空，右子树为G
	- 对于右子树(空树)：跳过
- 对于右子树ECF:
	- 通过先序序列找到树根是C，通过中序序列，划分得到左子树是E，右子树为F
	- 对于左子树E：
		- 无左右子树
	- 对于右子树F:
		- 无左右子树

根据以上分析，得到如下二叉树：
```text
    A
   / \
  B   C
 /   / \
D   E   F
 \ 
  G
```
--- 
# 七、线索二叉树

## 1.线索二叉树的概念

通过遍历二叉树，可以得到一个结点的线性序列。其中有一些空指针域，可以用来记录这样一个序列的前后关系。
- 当某结点的左指针为空时，让左指针指向遍历序列中的前驱结点
- 当某结点的右指针为空时，让右指针指向遍历序列中的后驱结点

## 2.存储结构

这样一来，还需要一个标志来区分左右指针指向的是孩子结点还是序列结点，将结点的存储结构改成这样：

```text
+------+--------+------+--------+------+
| ltag | lchild | data | rchild | rtag |
+------+--------+------+--------+------+
```

- 左标志 ltag:
	- 取0代表lchild指向的是左孩子结点
	- 取1代表lchild指向的是序列的前驱结点
- 右标志 rtag:
	- 取0代表rchild指向的是右孩子结点
	- 取1代表rchild指向的是序列的后继结点

对应的数据类型声明如下：

```cpp
typedef struct node {
	ElemType data;
	int ltag, rtag;
	struct node *lchild;
	struct node *rchild;
}
```

创建二叉树线索的过程称为**线索化**。线索化的二叉树称为**线索二叉树**。

---
例：对于上例中的二叉树，分别根据先序、中序和后序遍历得到的序列进行线索化，得到的线索二叉树如下图所示：
![](20260111092718907.png)

---
# 八、哈夫曼树

## 1.概述

- 将树中的结点赋予一个有意义的值，称为该结点的**权**，记为$w$
- 将从根结点到该结点之间的路径长度（记为$l$），乘以该结点上的权，称为结点的**带权路径长度**
- 一棵树的带权路径长度，是所有叶子结点的带权路径长度之和。记为：
$$
WPL=\sum_{i=1}^{n_0} w_il_i
$$

- **哈夫曼树**即最优二叉树，是$n_0$个结点中，带权路径长度最小的二叉树。
	- 需要注意的是，对于同一组叶子结点，其哈夫曼树是**不唯一**的。
## 2.哈夫曼树的构造算法

构造一棵二叉树的步骤如下：
1. 先把所有的叶子结点**从小到大**排序，组成一个叶子结点的有序序列；
2. 将最小的两个结点作为二叉树的左右孩子，添加一个新的根结点，权值为两个结点的和；
3. 将这棵二叉树的根结点作为一个叶子结点，放入第一步的序列中；
4. 循环进行上面的1-3步骤，直到所有的叶子结点都在同一棵二叉树中，得到哈夫曼树。

![](20260111094919443.jpg)
## 3.哈夫曼编码

在数据通信中，为了让字符编码的长度尽可能短，同时又不能混淆，通常使用哈夫曼树来编制每个字符对应的编码，称为**哈夫曼编码**。

哈夫曼编码的求算步骤如下：
1. 将所有字符按照出现频率从低到高排序，将频率作为权值构造哈夫曼树；
2. 将哈夫曼树的每个左支标上0，每个右支标上1
3. 从根结点出发，到达每个叶子结点，记录路径上的标记，即为该叶子结点对应字符的哈夫曼编码。

哈夫曼编码是不定长的**前缀码**（任意一个编码都不为其他编码的前缀）

--- 
例1：通过构造哈夫曼树，求出各字符的哈夫曼编码
![](20260111095640477.png)

--- 
例2：已经有1，01这两个编码，最多使用四位进行编码，还能编码多少个字符？

解：最多使用四位，说明哈夫曼树最多有四层，且1，01这两个结点是叶子结点。画出哈夫曼树，补充尽可能多的虚结点：
![](20260111101105504.png)

由图可知，还能够编码4个字符。

---
# 九、用并查集求解等价问题

## 1.并查集的定义

对于一系列的n个结点，将总体称为集合U，给定等价关系R对结点U进行划分，得到一系列互不相交的等价类$S_1、S_2、 \dots、S_n$。

其中需要使用这些运算：

1. 初始化集合S
2. 查找x结点属于哪一个等价类
3. 将x,y所属的两个等价类合并

对结点的**查找**和等价类的**合并**，最终形成一些集合，称为**并查集**。

## 2.并查集的树结构实现

将并查集看作一个森林，其中的每个等价类都是一棵有根树，用根结点来作为等价类的代表。树中的结点集合是全集U的一个子集，因此这些树又称为**子集树**。每棵子集树都采用双亲存储结构来进行存储，其结点类型声明如下：

```cpp
typedef struct {
	int rank;    // 结点秩（结点对应子树高度的下界）
	int parent;  // 结点的双亲
} UFSTree
```
