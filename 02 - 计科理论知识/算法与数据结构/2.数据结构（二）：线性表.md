---

---
--- 
> 声明：本篇笔记摘自[《数据结构教程》 - 清华大学出版社](http://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC5%E7%89%88%EF%BC%89/22216268?fromModule=search-result_lemma)，遵循[CC BY 4.0协议](https://creativecommons.org/licenses/by/4.0/legalcode.zh-hans)。
> 存在由AI生成的小部分内容，仅供参考，请仔细甄别可能存在的错误。
--- 
# 一、线性表及其逻辑结构

## 1.定义

- **线性表**：具有相同特性的数据元素的一个有限序列。
- 线性表的**长度**：线性表中所含元素的个数n。
- 线性表的一般表示方式：($a_1$, $a_2$, ..., $a_n$)
	- 其中$a_1$和$a_n$分别表示表头元素和表尾元素
- 线性表中的元素满足线性关系，即第i个元素在第i+1个元素的前面，第i-1个元素的后面
- 线性表满足以下三个特点：
	- 有穷性：线性表中的元素个数有限
	- 一致性：线性表中的元素性质相同
	- 序列性：所有元素的相对位置是线性的，即存在唯一的开始元素和结束元素
- 线性表中的元素的位置只与序号有关，因此可以存储值重复的元素
## 2.ADT描述

```ADT
ADT List
{
	数据对象：
		D = {a[i] | 1<=i<=n, n>=0; a[i]为ElementType类型}
	数据关系：
		R = {<a[i], a[i+1]> | a[i], a[i+1] 属于 D, i=1, 2,..., n-1}
	基本运算：
		InitList(&L)：初始化线性表，构造空线性表L
		DestoryList(&L)：销毁线性表，释放为L创建的内存空间
		ListEmpty(L)：判断L是否为空
		ListLength(L)：求线性表长度
		DispList(L)：输出线性表，当L不为空时顺序输出其中的元素
		GetElem(L, i, &e)：按序号获取线性表中的元素，用e返回L中第i个元素的值
		LocateElem(L, e)：返回L中第一个值与e相等的元素序号
		ListInsert(&L, i, e)：在L的第i个位置插入元素e
		ListDelete(&L, i, &e)：删除L的第i个元素，并且用e返回元素值
}
```

为了实现对顺序表的修改和参数的输出，基本运算中的参数有一些带有&，表示是引用参数。
# 二、线性表的顺序存储结构

## 1.顺序表

线性表的顺序存储，即将线性表的元素按照逻辑顺序，依次存储到一块连续的内存中。
线性表的顺序存储结构简称为**顺序表**。

顺序表的结构体类型如下：
```c++
#define MaxSize 50

typedef struct {
	ElementType data[MaxSize];
	int length;
} SqList;
```

## 2.基本运算实现

```cpp
// 顺序表
#include <iostream>
#include <cstdlib>

#define MaxSize 50
typedef int ElemType;

typedef struct {
	ElemType data[MaxSize];
	int length;
} SqList;

// 建立顺序表
void CreateList(SqList *&L, ElemType a[], int n) {
    int i = 0, k = 0;
	L = (SqList *)malloc(sizeof(SqList));
	while (i < n) {                  // 存储a[]中的前n个元素
		L->data[k] = a[i];
		k++;i++;
	}
	L->length = k;
}


// 初始化顺序表
void InitList(SqList *&L) {
	L = (SqList *)malloc(sizeof(SqList));
	L->length = 0;
}

// 销毁线性表
void DestoryList(SqList *&L) {
	free(L);
}

// 判断表空
bool ListEmpty(SqList *L) {
	return(L->length==0);
}

// 求线性表的长度
int ListLength(SqList *L) {
	return(L->length);
}

// 输出线性表
void DispList(SqList *L) {
	for (int i = 0; i < L->length; i++) {
		printf("%d ", L->data[i]);
	}
	printf("\n");
}

// 按序号求线性表中的元素
bool GetElem(SqList *L, int i, ElemType &e) {
	if (i < 1 || i > L->length) {
		return false;
	}
	e = L->data[i-1];
	return true;
}

// 按元素值查找
int LocateElem(SqList *L, ElemType e) {
	int i = 0;
	while (i < L->length && L->data[i] != e) {
		i++;
	}
	if (i >= L->length) {
		return 0;
	} else {
		return i+1;
	} 
}

// 插入数据元素
bool ListInsert(SqList *&L, int i, ElemType e) {
    int j;
	if (i < 1 || i > L->length + 1 || L->length == MaxSize) {
		return false;
	}
	i--;
	for(j=L->length;j>i;j--) {
		L->data[j] = L->data[j-1];
	}
	L->data[i] = e;
	L->length++;
	return true;
}

// 删除数据元素
bool ListDelete(SqList *&L, int i, ElemType &e) {
    int j;
	if (i < 1 || i > L->length + 1 || L->length == MaxSize) {
		return false;
	}
	i--;
	e = L ->data[i];
	for(j=i; j<L->length-1; j++) {
		L ->data[j] = L->data[j+1];
	}
	L->length--;
	return true;
}

int main() {
    SqList *L = NULL;
    ElemType a[] = {1, 2, 3, 4, 5};
    int n = sizeof(a) / sizeof(a[0]);
    ElemType e;
    bool res;

    // 1. 测试创建顺序表
    printf("1. 创建顺序表，初始元素：");
    CreateList(L, a, n);
    DispList(L);  // 输出：1 2 3 4 5

    // 2. 测试表长度
    printf("2. 顺序表长度：%d\n", ListLength(L));  // 输出：5

    // 3. 测试判断表空
    printf("3. 顺序表是否为空：%s\n", ListEmpty(L) ? "是" : "否");  // 输出：否

    // 4. 测试按序号查找元素
    res = GetElem(L, 3, e);
    if (res) {
        printf("4. 查找第3个元素：%d\n", e);  // 输出：3
    } else {
        printf("4. 查找第3个元素：失败\n");
    }

    // 5. 测试按值查找元素
    int pos = LocateElem(L, 4);
    if (pos != 0) {
        printf("5. 查找元素4的位置：第%d个\n", pos);  // 输出：第4个
    } else {
        printf("5. 查找元素4：未找到\n");
    }

    // 6. 测试插入元素
    res = ListInsert(L, 2, 99);
    if (res) {
        printf("6. 在第2个位置插入99后，顺序表：");
        DispList(L);  // 输出：1 99 2 3 4 5
    } else {
        printf("6. 插入元素失败\n");
    }

    // 7. 测试删除元素
    res = ListDelete(L, 4, e);
    if (res) {
        printf("7. 删除第4个元素，被删除的元素：%d，删除后顺序表：", e);
        DispList(L);  // 输出：1 99 2 4 5
    } else {
        printf("7. 删除元素失败\n");
    }

    // 8. 测试初始化空表
    SqList *L2 = NULL;
    InitList(L2);
    printf("8. 初始化空表，是否为空：%s\n", ListEmpty(L2) ? "是" : "否");  // 输出：是

    // 9. 销毁顺序表
    DestoryList(L);
    DestoryList(L2);
    printf("9. 顺序表已销毁\n");

    return 0;
}
```

- `*L` 与 `*&L` 的区别：
	- `*L` 是指针的值传递，只能修改指针指向的**数据内容**，不能改指针本身的指向；
	- `*&L` 是指针的引用传递，既能改数据内容，也能改指针的指向；
- 选择原则：仅操作表内容用 `*L`，需要给指针分配/释放内存、改指向时用 `*&L`（避免无意义的引用传递，减少风险）。

- 建立线性表的过程：
	- 先在main函数中通过 `SqList *L = NULL;` 新建一个空的指针
	- 然后调用创建线性表的方法，核心操作为 `L = (SqList *)malloc(sizeof(SqList));`，给L分配内存空间

# 三、线性表的链式存储结构

## 1.链表

- 线性表的链式存储结构称为**链表**。
- 线性表的每个元素采用一个**内存结点**存储
	- 每个内存结点包含元素的数据信息（**数据域**）和元素之间的逻辑关系（**指针域**）
- **单链表**：只设置一个指针域，指向后继结点
- **双链表**：设置两个指针域，分别指向前驱结点和后继结点
- **头指针**：每个链表带有一个头结点，头结点的指针（**头指针**）唯一标识该链表
- **首指针、尾指针**：指向链表首结点和尾结点的指针
![](20260108162843517.jpg)

与顺序表相比，链表进行插入和删除的操作比较方便，只需修改指针域即可；
但是链表不具有随机存取性，查找第i个元素的处理比顺序表要复杂一些。

由于指针域的存在，链表的**存储密度**（结点中数据域的空间占用/整个结点的空间占用）低于顺序表。
## 2.单链表

#### ① 相关概念

单链表的结点 `LinkNode` 的类型声明如下：
```cpp
typedef struct LNode {
	ElemType data;
	struct LNode *next;
} LinkNode;
```

这里的 `LNode` 是 `struct LNode` 这个结构体的**标签名（tag name）**，可以把它理解成这个结构体的 “小名”，核心作用是：

- 在结构体内部定义 `next` 指针时，需要用 `struct LNode *next` 来声明 “指向同类型结构体的指针”（因为此时 `LinkNode` 还没完全定义好，只能用 `struct LNode`）；
- 结合前面的 `typedef`，最终把 `struct LNode` 这个复杂的类型名，简化成了 `LinkNode`（可以把 `LinkNode` 看作 “大名”）。

等价于分两步来写：

```cpp
struct LNode {   // 定义一个名为 LNode 的结构体
	ElemType data;
	struct LNode *next;
};

typedef struct LNode LinkNode;  // 把 struct LNode 这个类型，重命名为 LinkNode
```

在算法设计中，多使用带头结点的单链表。在单链表中添加头结点比较方便：
- 单链表的首结点插入与删除的处理，和对其他结点的处理方法一致
- 无论单链表是否为空，都有一个头结点，因此无需额外处理空表

### ② 单链表的插入操作

- 在单链表的两个数据域分别为a和b的结点中插入一个数据域为x的结点：
- 
```text
① 将x的next指向b
  a→ b
     ↑
  x->
  
② 将a的next指向x
  a  b
  ↓  ↑
  x->

③ 现在就成了 a→ x→ b→ 的结构，完成x的插入
```

注意这里需要“过河拆桥”，先把x连接到b的前面，再将a指向x与b切断联系。如果第一步就断开，整个链表就断了。
（可以理解为将一个圆环连接到一串中，需要先把圆环连接到串上再解开前面一个环连到新的环上，这样整个串才不会断）

### ③ 单链表的删除操作

在删除p的后继结点时，直接将 `p->next` 指向 `p->next->next` ，然后释放掉被删除的结点即可：

```cpp
q = p->next;
p->next = p->next->next;         
free(q);                       
```

### ④ 建立单链表

单链表的创建思路是遍历数组，将每个元素逐个填入结点的数据域，然后通过next指针挂载到链表上。

根据新结点插入的位置，单链表的创建方法分为**头插法**和**尾插法**：

```cpp
// 头插法：新数据插入到链表的头结点之后
void CreateListF(LinkNode *&L, ElemType a[], int n) {
	LinkNode *s;
	L = (LinkNode *)malloc(sizeof(LinkNode));
	L -> next = NULL;                          // 头结点，next为空
	for (int i = 0; i < n; i++) {              // 将数组元素逐个挂载到链表中
		s = (LinkNode *)malloc(sizeof(LinkNode));
		s->data = a[i];
		s->next = L->next;
		L->next = s;
	}
}

// 尾插法：新数据插入到表尾
void CreateListR(LinkNode *&L, ElemType a[], int n) {
	LinkNode *s, *r;
	L = (LinkNode *)malloc(sizeof(LinkNode));
	r = L; // r始终指向表尾，初始时指向头结点
		for (int i = 0; i < n; i++) {              // 将数组元素逐个挂载到链表中
		s = (LinkNode *)malloc(sizeof(LinkNode));
		s->data = a[i];
		r->next = s;
		r = s;  // 新插入的s成了现在的尾结点
	}
	r->next = NULL;
}
```

- 上面两个创建方法的时间复杂度均为O(n)
- 头插法建立的链表是倒序的，尾插法则是顺序的
- 尾插法建表更为多用，尤其是合并两个单链表时比较方便

### ⑤ 单链表的运算

```cpp
// 单链表

#include <iostream>
#include <cstdlib>

typedef int ElemType;

typedef struct LNode {
    ElemType data;
    struct LNode * next;
} LinkNode;

// 头插法：新数据插入到链表的头结点之后
void CreateListF(LinkNode *&L, ElemType a[], int n) {
	LinkNode *s;
	L = (LinkNode *)malloc(sizeof(LinkNode));
	L->next = NULL;                          // 头结点，next为空
	for (int i = 0; i < n; i++) {              // 将数组元素逐个挂载到链表中
		s = (LinkNode *)malloc(sizeof(LinkNode));
		s->data = a[i];
		s->next = L->next;
		L->next = s;
	}
}

// 尾插法：新数据插入到表尾
void CreateListR(LinkNode *&L, ElemType a[], int n) {
	LinkNode *s, *r;
	L = (LinkNode *)malloc(sizeof(LinkNode));
	r = L; // r始终指向表尾，初始时指向头结点
		for (int i = 0; i < n; i++) {              // 将数组元素逐个挂载到链表中
		s = (LinkNode *)malloc(sizeof(LinkNode));
		s->data = a[i];
		r->next = s;
		r = s;  // 新插入的s成了现在的尾结点
	}
	r->next = NULL;
}

// 初始化单链表
void InitList(LinkNode *&L) {
    L = (LinkNode *)malloc(sizeof(LinkNode));
    L->next = NULL;  // 空表的头指针next为空
}

// 销毁单链表
void DestoryList(LinkNode *&L) {
    LinkNode * pre = L; 
    LinkNode *p = L->next;  // pre->p
    while (p != NULL) {     // 当p非空，没走到表尾时
        free(pre);          // 先将pre释放掉
        pre = p;            // 然后将pre和p都往后走一个
        p = pre->next;      
    }
    free(pre);   // 走到表尾后，p=NULL, pre->p(NULL)称为最后一个元素，将其释放即可

}

// 判断线性表是否为空
bool ListEmpty(LinkNode *L) {
    return (L->next == NULL);  // 看头结点是否有后继元素即可
}

// 求单链表的长度写一个简单的main方法，测试一下这些函数
int ListLength(LinkNode *L) {
    int n = 0;
    LinkNode *p = L;
    while(p->next != NULL) {
        n++;
        p = p->next;
    }
    return n;
}

// 输出单链表
void DispList(LinkNode *L) {
    LinkNode *p = L->next; // 头结点不要打印，直接从首结点开始
    while(p != NULL) {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

// 按序号查找链表中的元素
bool GetElem(LinkNode *L, int i, ElemType &e) {
    int j = 0;
    LinkNode *p = L;
    if (i < 0) return false;
    while(j < i && p != NULL) {
        j++;
        p = p->next;
    }
    if (p == NULL) {   // 在找到第i个元素时或之前，已经没有后继元素了
        return false;
    } else {           // 找到了第i个元素
        e = p->data;
        return true;
    }
}

// 按元素查找位置
int LocateElem(LinkNode *L, ElemType e) {
    int i = 1;
    LinkNode *p = L->next;  // i的初值为1，从第一个结点（首结点）开始
    while (p!= NULL && p->data != e) {
        i++;
        p = p->next;
    }
    if (p == NULL) {
        return(0);
    } else {
        return(i);
    }
}

// 插入数据元素
bool ListInsert(LinkNode *&L, int i, ElemType e) {
    int j = 0;
    LinkNode *p = L, *s;
    if (i < 0) return false;
    while (j < i-1 && p != NULL) {   // 查找第i-1个元素
        j++;
        p = p->next;
     }
    if (p == NULL) return false;
    else {
        s = (LinkNode *)malloc(sizeof(LinkNode));
        s-> data = e;
        s ->next = p->next;    // 先过河
        p ->next = s;          // 再拆桥
        return true;
    }
}

// 删除数据元素
bool ListDelete(LinkNode *&L, int i, ElemType &e) {
    int j = 0;
    LinkNode *p = L;
    if (i < 0) return false;
    while (j < i-1 && p != NULL) {
        j++;
        p = p->next;
    }

    if (p == NULL) return false;
    else {
        LinkNode *q = p->next;
        if (q == NULL) {
            return false;
        }
        p->next = p->next->next;
        e = q->data;
        free(q);
        return true;
    }
}

// 测试用的main函数
int main() {
    LinkNode *L = NULL;
    LinkNode *L2 = NULL;
    ElemType a[] = {1, 2, 3, 4, 5};
    int n = sizeof(a) / sizeof(a[0]);
    ElemType e;
    bool res;

    // 1. 测试头插法创建链表
    printf("1. 头插法创建链表（数组[1,2,3,4,5]）：");
    CreateListF(L, a, n);
    DispList(L); // 输出：5 4 3 2 1（头插法是逆序）

    // 2. 测试尾插法创建链表
    printf("2. 尾插法创建链表（数组[1,2,3,4,5]）：");
    CreateListR(L2, a, n);
    DispList(L2); // 输出：1 2 3 4 5（尾插法是正序）

    // 3. 测试链表长度
    printf("3. 尾插法链表长度：%d\n", ListLength(L2)); // 输出：5

    // 4. 测试判断链表为空
    LinkNode *L3 = NULL;
    InitList(L3);
    printf("4. 初始化空链表是否为空：%s\n", ListEmpty(L3) ? "是" : "否"); // 输出：是

    // 5. 测试按序号查找元素
    res = GetElem(L2, 3, e);
    if (res) {
        printf("5. 查找尾插法链表第3个元素：%d\n", e); // 输出：3
    } else {
        printf("5. 查找第3个元素失败\n");
    }

    // 6. 测试按值查找位置
    int pos = LocateElem(L2, 4);
    if (pos != 0) {
        printf("6. 查找元素4的位置：第%d个\n", pos); // 输出：第4个
    } else {
        printf("6. 未找到元素4\n");
    }

    // 7. 测试插入元素
    res = ListInsert(L2, 2, 99);
    if (res) {
        printf("7. 在第2个位置插入99后，链表：");
        DispList(L2); // 输出：1 99 2 3 4 5
    } else {
        printf("7. 插入元素失败\n");
    }

    // 8. 测试删除元素
    res = ListDelete(L2, 4, e);
    if (res) {
        printf("8. 删除第4个元素，被删除的元素：%d，删除后链表：", e);
        DispList(L2); // 输出：1 99 2 4 5
    } else {
        printf("8. 删除元素失败\n");
    }

    // 9. 测试销毁链表
    DestoryList(L);
    DestoryList(L2);
    DestoryList(L3);
    printf("9. 所有链表已销毁\n");

    return 0;
}
```

观察对数据元素的查找、定位、增删操作，有这样固定的模式：
- **准备工作**：创建计数器j，指针p指向头结点或首结点，
- **检查参数**：位置为负直接返回false或0（表示找不到）
- **遍历链表**：尝试找到第i或者i-1个结点
- **判断存在**：若第i/i-1个元素不存在，返回false或0（表示找不到）
- **进行操作**：根据函数的目的对链表进行具体的操作，并返回操作结果

--- 
示例：删除单链表中数据域最大的结点算法如下：
```cpp
void delMaxElem(LinkNode *&L, ElemType &e) {
    if (L == NULL || L->next == NULL) {
        return;
    }
    
    LinkNode *p = L;     // 从头届点开始遍历整个单链表
    LinkNode *pre = L;   // pre记录max的前驱结点，方便后面进行删除操作
    LinkNode *max = L->next; //max初值为链表的首结点
    
    while (p->next != NULL) { // 遍历链表，获取数据域最大的结点
        if(p->next->data > max->data) {
            max = p->next;
            pre = p;    // pre始终指向max的前驱结点
        }
        p = p->next;
    }
    // 取下最大的结点，记录其值并销毁
    pre->next = max->next;
    e = max->data;
    free(max);
}
```
--- 
## 3.双链表

### ① 相关概念

双链表的结点 `DLinkNode` 的类型声明如下：
```cpp
typedef struct DNode {
	ElemType data;       // 数据域
	struct DNode *prior;   // 指向前驱结点
	struct DNode *next;  // 指向后继结点
} DLinkNode;
```

双链表可以方便地获取前、后结点，比单链表更加灵活。
### ② 双链表的插入操作

与单链表的插入类似，先链接上x再断开p与q原有的连接，防止链表断开。

![](20260108221523384.jpg)

### ③ 双链表的删除操作

![](20260108221527481.jpg)
### ④ 双链表的运算

> 双链表求长度、取值、查找操作与单链表相似，这里只展示不同的运算操作。

#### 头插法建表

```cpp
// 头插法建表
void CreateListF(DLinkNode * &L, ElemType a[], int n) //采用头插法建立双链表
//由含 n 个元素的数组 a 创建带头结点的双链表 L
{
    DLinkNode * s;
    L = (DLinkNode * )malloc(sizeof(DLinkNode));    //创建头结点
    L -> prior = L -> next = NULL;                  //前、后指针域置为 NULL
    for (int i = 0; i < n; i++)                     //循环建立数据结点
    {
        s = (DLinkNode * )malloc(sizeof(DLinkNode));
        s -> data = a[i];                           //创建数据结点 s
        s -> next = L -> next;                      //① 将 s 结点插入头结点之后
        if (L -> next != NULL)                      //② 若 L 非空, 修改 L -> next 的前驱指针
            L -> next -> prior = s;
        L -> next = s;                              // ③
        s -> prior = L;                             // ④
    }
}
```

头插法元素插入的详细操作图示，对应代码注释中的四个序号：

![](20260109100956122.png)

#### 尾插法建表

```cpp
// 尾插法建表
void CreateListR(DLinkNode * &L, ElemType a[], int n) //采用尾插法建立双链表
//由含 n 个元素的数组 a 创建带头结点的双链表 L
{
    DLinkNode * s, * r;
    L = (DLinkNode * )malloc(sizeof(DLinkNode));    //① 创建头结点
    r = L;                                          //① r 始终指向尾结点, 开始时指向头结点
    for (int i = 0; i < n; i++)                     //循环建立数据结点
    {
        s = (DLinkNode * )malloc(sizeof(DLinkNode));
        s -> data = a[i];                           //② 创建数据结点 s
        r -> next = s; s -> prior = r;              //③ 将 s 结点插入 r 结点之后
        r = s;                                      //④ r 指向尾结点
    }
    r -> next = NULL;                               //将尾结点的 next 域置为 NULL
}
```

尾插法元素插入的详细操作图示，对应代码注释中的四个序号：

![](20260109103052007.png)

#### 插入元素

```cpp
bool ListInsert(DLinkNode * &L, int i, ElemType e)
{
    int j = 0;
    DLinkNode * p = L, * s;                    //p 指向头结点, j 设置为 0
    if (i <= 0) return false;                  //i 错误返回 false
    while (j < i - 1 && p != NULL)             //查找第 i-1 个结点
    {
        j++;
        p = p -> next;
    }
    if (p == NULL)                             //未找到第 i-1 个结点, 返回 false
        return false;
    else                                       //找到第 i-1 个结点 p
    {
        s = (DLinkNode * )malloc(sizeof(DLinkNode)); //创建新结点 s
        s -> data = e;
        s -> next = p -> next;                 //在 p 结点之后插入 s 结点
        if (p -> next != NULL)                 //若 p 结点存在后继结点, 修改其前驱指针
            p -> next -> prior = s;
        s -> prior = p;
        p -> next = s;
        return true;
    }
}
```

![](20260109104601218.png)

#### 删除元素

```cpp
bool ListDelete(DLinkNode * &L, int i, ElemType &e)
{
    int j = 0;
    DLinkNode * p = L, * q;                    //p 指向头结点, j 设置为 0
    if (i <= 0) return false;                  //i 错误返回 false
    while (j < i - 1 && p != NULL)             //查找第 i-1 个结点 p
    {
        j++;
        p = p -> next;
    }
    if (p == NULL)                             //未找到第 i-1 个结点 p
        return false;
    else                                       //找到第 i-1 个结点 p
    {
        q = p -> next;                         //q 指向第 i 个结点
        if (q == NULL)                         //当不存在第 i 个结点时返回 false
            return false;
        e = q -> data;
        p -> next = q -> next;                 //从双链表中删除结点 q
        if (q -> next != NULL)                 //若 q 结点存在后继结点, 修改其前驱指针
            q -> next -> prior = p;
        free(q);                               //释放 q 结点
        return true;
    }
}
```

![](20260109105201523.png)

## 3.循环链表

**循环链表**即尾结点指向头结点的链表，由其中任意一个元素顺着next或pre指针可以访问所有的元素。

循环链表的结点类型与非循环链表相同；也有循环单链表和循环双链表之分。

![](20260109105537967.jpg)

# 四、有序表

**有序表**是指元素按照递增/递减排序的线性表。这里只考虑递增有序表，递减有序表同理。

## 1.ADT描述

```ADT
ADT OrderList {
	数据对象：
		D = {a[i] | 1<=i<=n, n>=0; a[i]为ElementType类型}
	数据关系：
		R = {<a[i], a[i+1]> | a[i], a[i+1] 属于 D,且 a[i] <= a[i+1]， i=1，2， ...., n-1}
	基本运算：
		InitList(&L)：初始化有序表
		DestoryList(&L)：销毁有序表，释放为L创建的内存空间
		ListEmpty(L)：判断L是否为空
		ListLength(L)：求有序表元素个数
		DispList(L)：输出有序表，当L不为空时顺序输出其中的元素
		GetElem(L, i, &e)：按序号获取有序表中的元素，用e返回L中第i个元素的值
		LocateElem(L, e)：返回L中第一个值与e相等的元素序号
		ListInsert(&L, i)：在L中插入元素e
		ListDelete(&L, i, &e)：删除L的第i个元素，并且用e返回元素值
}
```

## 2.存储结构及基本运算算法

有序表中只有插入的算法需要确定插入的位置，其他的算法与顺序表/链表相同，参考顺序表或链表的处理方法即可。