---

---
--- 
> 声明：存在由AI生成的部分内容，仅供参考，请仔细甄别可能存在的错误。

# 一、原题展现

 P1205 \[USACO1.2] 方块转换 Transformations: https://www.luogu.com.cn/problem/P1205

## 题目描述

一块 $n \times n$ 正方形的黑白瓦片的图案要被转换成新的正方形图案。写一个程序来找出将原始图案按照以下列转换方法转换成新图案的最小方式：

- 转 $90\degree$：图案按顺时针转 $90\degree$。
- 转 $180\degree$：图案按顺时针转 $180\degree$。
- 转 $270\degree$：图案按顺时针转 $270\degree$。
- 反射：图案在水平方向翻转（以中央铅垂线为中心形成原图案的镜像）。
- 组合：图案在水平方向翻转，然后再按照 $1 \sim 3$ 之间的一种再次转换。
- 不改变：原图案不改变。
- 无效转换：无法用以上方法得到新图案。

如果有多种可用的转换方法，请选择序号最小的那个。只使用上述 $7$ 个中的一个步骤来完成这次转换。

## 输入格式

第一行一个正整数 $n$。   
然后 $n$ 行，每行 $n$ 个字符，全部为 `@` 或 `-`，表示初始的正方形。
接下来 $n$ 行，每行 $n$ 个字符，全部为 `@` 或 `-`，表示最终的正方形。

## 输出格式

单独的一行包括 $1 \sim 7$ 之间的一个数字（在上文已描述）表明需要将转换前的正方形变为转换后的正方形的转换方法。

## 输入输出样例 #1

### 输入 #1

```

3
@-@
\---
@@-
@-@
@--
--@
```
### 输出 #1

```
1
```

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10$。
题目翻译来自 NOCOW。
USACO Training Section 1.2

# 二、完全模拟过程的代码

作为首次接触`普及/提高−`难度的算法小白，我起初只能勉强写出这样的程序：

``` cpp
#include <iostream>
using namespace std;

char a[11][11];
char temp[11][11];
char ap[11][11];
char target[11][11];

// 旋转一次90度
void rotate(int n)
{
    char tmp[11][11];
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            tmp[j][n - i - 1] = ap[i][j];
        }
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            ap[i][j] = tmp[i][j];
        }
    }
}

// 反射
void reflect(int n)
{
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n / 2; j++)
        {
            char t = ap[i][j];
            ap[i][j] = ap[i][n - j - 1];
            ap[i][n - j - 1] = t;
        }
    }
}

// 判定结果与目标是否相等
bool isEqual(int n)
{
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (target[i][j] != ap[i][j])
            {
                return false;
            }
        }
    }
    return true;
}

// 拷贝原图a到ap
void copyOriginal(int n)
{
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            ap[i][j] = a[i][j];
        }
    }
}

int main(void)
{
    int n;
    cin >> n;

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            cin >> a[i][j];
            ap[i][j] = a[i][j];
        }
    }

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            cin >> target[i][j];
        }
    }

    // 1. 转90度
    copyOriginal(n);
    rotate(n);
    if (isEqual(n))
    {
        cout << 1;
        return 0;
    }

    // 2. 转180度
    copyOriginal(n);
    rotate(n);
    rotate(n);
    if (isEqual(n))
    {
        cout << 2;
        return 0;
    }

    // 3. 转270度
    copyOriginal(n);
    rotate(n);
    rotate(n);
    rotate(n);
    if (isEqual(n))
    {
        cout << 3;
        return 0;
    }

    // 4. 反射
    copyOriginal(n);
    reflect(n);
    if (isEqual(n))
    {
        cout << 4;
        return 0;
    }

    // 5. 反射 + 旋转
    copyOriginal(n);
    reflect(n);
    rotate(n);
    if (isEqual(n))
    {
        cout << 5;
        return 0;
    }
    copyOriginal(n);
    reflect(n);
    rotate(n);
    rotate(n);
    if (isEqual(n))
    {
        cout << 5;
        return 0;
    }
    copyOriginal(n);
    reflect(n);
    rotate(n);
    rotate(n);
    rotate(n);
    if (isEqual(n))
    {
        cout << 5;
        return 0;
    }

    // 6. 不变
    copyOriginal(n);
    if (isEqual(n))
    {
        cout << 6;
        return 0;
    }

    // 7. 无效
    cout << 7;
    return 0;
}
```

虽然说可以通过所有测试点，但是时间复杂度和空间复杂度占用都非常不理想，开了四个很大的数组不说，不理想状况下甚至有多达十几次二重循环，属于是拉了座狗看了都摇头的史山…

![](20251029231624952.png)

# 三、优化与改进

> 我：这样的写法无论是时间还是空间上的使用都非常低效，能否有更好的优化思路？
> 
> DeepSeek：你说得对，这个代码确实有很多重复操作和冗余拷贝。我们可以从以下几个方面优化。

1. **避免数据拷贝**
	- 直接在原数据上计算变换后的坐标进行比较，不实际旋转矩阵
	- 使用函数 `checkTransformation(n, type)` 直接比较
2. **统一变换逻辑**
	- 用一个函数处理所有变换的坐标映射
	- 减少重复代码
3. **提前终止**
	- 一旦发现不匹配就立即停止比较

以下是DeepSeek经过优化之后的程序：

``` cpp
#include <iostream>
using namespace std;

char original[11][11];
char target[11][11];
int n;

// 定义坐标结构体
struct Position {
    int row;
    int col;
};

// 检查从(i,j)经过变换后是否匹配target
bool checkTransform(Position (*transform)(int, int)) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            Position new_pos = transform(i, j);
            if (original[i][j] != target[new_pos.row][new_pos.col]) {
                return false;
            }
        }
    }
    return true;
}

// 各种变换的坐标映射函数 - 返回Position结构体
Position rotate90(int i, int j) { 
    return {j, n - 1 - i}; 
}

Position rotate180(int i, int j) { 
    return {n - 1 - i, n - 1 - j}; 
}

Position rotate270(int i, int j) { 
    return {n - 1 - j, i}; 
}

Position reflect(int i, int j) { 
    return {i, n - 1 - j}; 
}

// 组合变换：先反射再旋转
Position reflectAndRotate90(int i, int j) { 
    int ref_j = n - 1 - j;
    return {ref_j, n - 1 - i}; 
}

Position reflectAndRotate180(int i, int j) {
    int ref_j = n - 1 - j;
    return {n - 1 - i, n - 1 - ref_j};
}

Position reflectAndRotate270(int i, int j) {
    int ref_j = n - 1 - j;
    return {n - 1 - ref_j, i};
}

// 不变
Position noChange(int i, int j) { 
    return {i, j}; 
}

int main() {
    cin >> n;
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> original[i][j];
        }
    }
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> target[i][j];
        }
    }

    // 按顺序检查各种变换
    if (checkTransform(rotate90)) {
        cout << 1;
    } else if (checkTransform(rotate180)) {
        cout << 2;
    } else if (checkTransform(rotate270)) {
        cout << 3;
    } else if (checkTransform(reflect)) {
        cout << 4;
    } else if (checkTransform(reflectAndRotate90) || 
               checkTransform(reflectAndRotate180) || 
               checkTransform(reflectAndRotate270)) {
        cout << 5;
    } else if (checkTransform(noChange)) {
        cout << 6;
    } else {
        cout << 7;
    }

    return 0;
}
```

可以看到DeepSeek的几个重点优化角度：

1. **不使用辅助矩阵**：直接操作原数据，避免多次拷贝占用内存、耗费时间
2. **使用坐标映射函数**：重点优化了旋转的逻辑，比直观上的模拟操作更优雅高效

此外，DeepSeek还给出了一个基于**lambda表达式**的极致优化版本，将原本`172`行代码“压缩”到了`42`行，同样能够顺利通过测试点：

```cpp
#include <iostream>
using namespace std;

char a[11][11], b[11][11];
int n;

bool check(auto f) {
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            if (a[i][j] != b[f(i, j).first][f(i, j).second])
                return false;
    return true;
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> a[i][j];
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> b[i][j];
    
    auto rot90 = [&](int i, int j) { return make_pair(j, n-1-i); };
    auto rot180 = [&](int i, int j) { return make_pair(n-1-i, n-1-j); };
    auto rot270 = [&](int i, int j) { return make_pair(n-1-j, i); };
    auto refl = [&](int i, int j) { return make_pair(i, n-1-j); };
    auto same = [&](int i, int j) { return make_pair(i, j); };
    
    if (check(rot90)) cout << 1;
    else if (check(rot180)) cout << 2;
    else if (check(rot270)) cout << 3;
    else if (check(refl)) cout << 4;
    else if (check([&](int i, int j) { return rot90(refl(i, j).first, refl(i, j).second); }) ||
             check([&](int i, int j) { return rot180(refl(i, j).first, refl(i, j).second); }) ||
             check([&](int i, int j) { return rot270(refl(i, j).first, refl(i, j).second); }))
        cout << 5;
    else if (check(same)) cout << 6;
    else cout << 7;
    
    return 0;
}
```

# 四、结束语

以上三个版本的程序都可以通过测试，且成绩都在`4ms/788.0KB`左右。或许是因为数据量不大的原因（我写到后面还一度以为会TLE），如果n能取到千/万级别，后两个优化版本或许能展现出更优秀的性能。（这么一看我写的那堆玩意似乎也不是很糟糕🤔…）