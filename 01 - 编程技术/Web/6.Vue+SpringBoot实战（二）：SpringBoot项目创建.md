---

---
--- 
> 参考资料：[带小白做毕设2025系列课程](https://www.javaxmsz.cn/courseDetail?id=78)，本篇笔记遵循[CC BY 4.0协议](https://creativecommons.org/licenses/by/4.0/legalcode.zh-hans)。
> 存在由AI生成的小部分内容，仅供参考，请仔细甄别可能存在的错误。本系列文章只记录一些常用操作和模板化代码，适合有Vue+SpringBoot开发经验的读者查阅。
--- 
# 一、开发环境

## 1.软件环境

IDE：Intellij IDEA 2023+
项目管理：Maven
Java：JDK 21+
前置知识：JavaSE、JavaWeb

## 2.工程创建

![](20260106143041794.png)

## 3.项目化简

图中标蓝文件可直接删除，保留必要的项目文件即可。

![](20260106143423936.png)

 `test` 目录、`resources`里面的`static`和`template`文件夹都可以删除。

## 4.项目结构介绍

![](20260106143513088.png)

- **.idea**：idea 软件的配置文件（不用管它）
- **src**：源码的目录
	- **SpringbootApplication**： 工程的启动类
	- **application.yml**：Springboot 的配置文件
- **target**：源码编译后的文件目录
- **pom.xml**：依赖管理文件（类似Vue中的**package.json**）

## 5.自定义端口

Spring Boot默认在8080端口启动，也可以自定义修改为其他指定的端口：

为了提高可读性，建议把 `application.properties` 改为 `application.yml`。

在 `application.yml` 中，将 `server` 下的 `port` 设置为其他的一个闲置端口：

![](20260106144235856.png)

# 二、测试Spring Boot

在 `src/main/java/com.example` 下，新建`controller/WebController.java`，写入如下代码：

``` java
package com.example.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class WebController {
    //  一个 get请求的接口
    @GetMapping("/hello") // 接口的路径，全局唯一不能有重复
    public String hello() {
        return "Hello Spring Boot！";  // 接口的返回值
    }
}
```

在浏览器中打开 `localhost:9999/hello`，可以看到打印出了 `Hello Spring Boot!` 的内容，说明SpringBoot启动成功，配置没有问题。

# 三、基础框架搭建

## 1.项目结构规范

在 `src/main/java/com.example` 中，刚才已经新建了controller文件夹用于存放各种控制器，现在继续新建以下文件夹：

- **entity**：用于存放实体类
- **service**：用于存放各种服务的定义
- **mapper**：用于存放与数据库交互的逻辑
- **exception**：用于存放定义的异常

当前端发起某个请求时，先到达Controller，在控制器中调用相应的Service，进行相关逻辑的处理；Service通过调用mapper中定义的方法来向数据库进行读写。有些情况下，数据的操作以实体类为单位进行处理会比较方便，如进行学生数据的导出时，mapper可以直接把SQL查询的结果处理成对象数组 `List<Student>`，这样在service中进行查询、排序、统计等操作就很爽快了。

这就类似于一个物流公司，在处理**外部发起的存储/调取工单**（前端发起的请求）时，先由**中心控制室**（controller）通知对应的**车间**（service）进行处理，**车间**（services）操作**叉车**（mapper）进入**仓库**（数据库）进行**存储/取出**（数据读写）。

## 2.包装类 Result

为了方便前端处理数据，我们需要规范Spring Boot响应数据的格式。可以考虑定义一个 `Result` 类，将响应数据都放进这个类的 `data` 字段中，然后附上 `msg`、`code` 这些附加信息、状态码等内容，以便前端有更好的用户体验。

新建 `common/Result.java`，参考如下代码定义一个Result类：

```java
package com.example.common;

public class Result {
    private String code;
    private Object data;
    private String msg;

    public static Result success() {
        Result result = new Result();
        result.setCode("200");
        result.setMsg("请求成功");
        return result;
    }

    public static Result success(Object data) {
        Result result = new Result();
        result.setCode("200");
        result.setData(data);
        result.setMsg("请求成功");
        return result;
    }

    public static Result error(String msg) {
        Result result = new Result();
        result.setCode("500");
        result.setMsg(msg);
        return result;
    }

    public static Result error(String code, String msg) {
        Result result = new Result();
        result.setCode(code);
        result.setMsg(msg);
        return result;
    }


    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }
}
```

例如在处理前端发起的数据查询请求时，我们使用 `Result.success("查询成功")`、`Result.error("无权限")` 或者 `Result.error("查询失败，无数据")` 就能很人性化地在返回数据的同时给前端附带上一些信息，以便前端具体告知用户操作的结果。

## 3.异常处理

### ① 异常捕获

有时后端报错会直接抛给前端，我们需要**统一捕获并处理 `com.example.controller` 包下所有控制器抛出的异常**，避免异常直接暴露给前端，提升系统的健壮性和用户体验。

新建 `exception/GlobalExceptionHandler.java`，参考如下的写法：

``` java
package com.example.exception;

import com.example.common.Result;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * 全局异常捕获器
 */
@ControllerAdvice("com.example.controller") /* 捕获controller中的自定义异常 */
public class GlobalExceptionHandler {
	private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);
	
	@ExceptionHandler(Exception.class)
	@ResponseBody // 将result对象转换成 json的格式
	public Result error(Exception e) {
		log.error("系统异常", e);
		return Result.error("系统异常");
	}
	
    @ExceptionHandler(CustomerException.class)
    @ResponseBody // 将result对象转换成 json的格式
    public Result customerError(CustomerException e) {
        log.error("自定义错误", e);
        return Result.error(e.getCode(), e.getMsg());
    }
	
}
```

### ② 自定义异常

当业务代码里遇到“预期中的错误”时，可以抛出一个**带错误码和错误信息**的异常，方便上层（比如前面的全局异常处理器）统一捕获并返回给前端。

新建 `exception/CustomException.java`，参考如下的写法：

```java
package com.example.exception;

/**
 * 自定义异常
 * 运行时异常
 */
public class CustomerException extends RuntimeException {
    private String code;
    private String msg;

    public CustomerException(String code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public CustomerException(String msg) {
        this.code = "500";
        this.msg = msg;
    }

    public CustomerException() {}

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }
}
```

小技巧：使用快捷键 `alt+insert` 自动编写 `getter/setter`：

![](20260106162059801.png)

### ③异常捕获实例

实现一个登录接口：

controller:
```java
@GetMapping("/login")
public Result admin(String name) {
    String admin = adminService.admin(name);
    return Result.success(admin);
}
```

service:
``` java
package com.example.service;

import com.example.exception.CustomerException;
import org.springframework.stereotype.Service;

@Service
public class AdminService {

    public String admin(String name) {
        if ("admin".equals(name)) {
            return "admin";
        } else {
            throw new CustomerException("账号错误"); // 自定义异常的使用
        }
    }

}
```

# 四、整合MyBatis实现数据库操作

## 1.软件环境

- MySQL5.7 或 8.x
- Navicat（数据库可视化工具）

**前置知识：SQL语句、MySQL基础知识**

## 2.新建数据库、新建表：

直接在Navicat中操作：

![](20260106154228747.png)

新建查询-输入SQL语句建表：

```sql
CREATE TABLE `admin` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `username` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '账号',
  `password` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '密码',
  `name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '名称',
  `phone` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '手机',
  `email` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '邮箱',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='管理员信息';
```

## 3.集成MyBatis

Mybatis 官网：[https://mybatis.org/mybatis-3/zh_CN/index.html](https://mybatis.org/mybatis-3/zh_CN/index.html)

在 `pom.xml` 里面添加 `Mysql` 依赖和 `MyBatis` 依赖：

```xml
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <scope>runtime</scope>
</dependency>

<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>3.0.3</version>
</dependency>
```

最后一步，安装插件 `MyBatisX`。

![](20260106171711518.png)

配置 `application.yml`：

``` yml
# 数据库配置
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: [root账号的密码]
    url: jdbc:mysql://localhost:3306/[数据库名称]?useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true&useSSL=false&serverTimezone=GMT%2b8&allowPublicKeyRetrieval=true
# 配置mybatis实体和xml映射
mybatis:
  ## 映射xml
  mapper-locations: classpath:mapper/*.xml  # 扫描resources/mapper/*.xml
  configuration:
    # 配置日志
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
    map-underscore-to-camel-case: true  # 自动把下划线转为驼峰，如is_admin -> isAdmin
```

classpath: -> 表示resources的目录

# 五、实现简单的用户数据接口

## 1.创建实体类 Admin

新建 `entity/Admin.java`,该类的字段需与数据库保持一致，在数据库映射的xml文件中使用：

```java
package com.example.entity;

/**
 * 管理员信息
 */
public class Admin {
    private Integer id;  // 可以为null，更有包容性，更多使用包装类如Integer而不是int
    private String username;
    private String password;
    private String phone;
    private String email;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}
```

## 2.创建数据库映射xml文件

在 `resources` 文件夹中创建 `mapper` 文件夹，然后创建 `adminMapper.xml` 文件：

参考 [MyBatis官网](https://mybatis.org/mybatis-3/zh_CN/getting-started.html)给出的格式，写出以下的数据库映射：

```java
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.mapper.AdminMapper">

</mapper>
```

## 3.创建Mapper层

在 `controller` 同级的 `mapper` 文件夹下，创建 `AdminMapper.java`，注意这里选择interface，即创建的是接口而不是class。

```java
package com.example.mapper;

import com.example.entity.Admin;
import java.util.List;

public interface AdminMapper {

    List<Admin> selectAll();

}
```

由于安装了 MyBatisX 插件可以看到接口Mapper的左侧出现了红色小鸟的标志，点击可以跳转到对应的xml文件。

![](20260106172352882.png)

## 4.顺带写出controller-service-mapper一整套接口：

AdminController:
```java
@RestController
@RequestMapping("/admin")
public class AdminController {

    @Resource
    AdminService adminService;

    @GetMapping("/selectAll")  //   完整的请求路径：http://localhost:9999/admin/selectAll
    public Result selectAll() {
        List<Admin> adminList = adminService.selectAll();
        return Result.success(adminList);
    }

}
```

AdminService
```java
@Service
public class AdminService {

    @Resource
    AdminMapper adminMapper;

    public List<Admin> selectAll() {
        return adminMapper.selectAll();
    }

}
```

AdminMapper
```java
public interface AdminMapper {

    List<Admin> selectAll();

}
```

AdminMapper.xml
```java
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.mapper.AdminMapper">

    <select id="selectAll" resultType="com.example.entity.Admin">
        select * from `admin` order by id desc
    </select>

</mapper>
```

访问localhost:9999/admin/selectAll，可以看到获取到了数据库中的数据：

![](20260107084942328.png)