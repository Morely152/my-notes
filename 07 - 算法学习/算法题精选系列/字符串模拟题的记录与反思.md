---

---
---- 
> 最近在练洛谷算法题的字符串专题时，因为自己的水平和思维不够，走了一些弯路，也同时学到了一些更好的处理方式；这里分享出来，大家一起学习讨论；包含部分AI生成内容，仅供参考，请仔细甄别可能存在的错误。
# 一、[P1321 单词覆盖还原](https://www.luogu.com.cn/problem/P1321)

## 1.原题

原题链接： https://www.luogu.com.cn/problem/P1321

> **题目描述**
> 我有一个长度为 l 的字符串，最开始时，这个字符串由 l 个句号（.）组成。
> 我在这个字符串中，将多次把 boy 或者 girl 两单词，依次贴到这个字符串中。
> 后贴上单词，会覆盖之前贴上的单词，或者覆盖句号。最终，每个单词至少有一个字符没有被覆盖。
> 请问，一共贴有几个 boy 几个 girl？
> **输入格式**
> 一行被反复贴有 boy 和 girl 两单词的字符串。
> **输出格式**
> 两行，两个整数。第一行为 boy 的个数，第二行为 girl 的个数。
> **输入输出样例**
> **输入 #1**
> ......boyogirlyy......girl.......
> **输出 #1**
> 4
> 2
> **说明/提示**
> 数据保证，3≤l≤255，字符串仅仅包含如下字符：.bgilory。

## 2.差解

```cpp
#include <iostream>
using namespace std;

int main(void) {
    string s;
    int bn = 0;
    int gn = 0;
    getline(cin, s);

    // 查询四字符组合
    for (int i = 0; i < s.length()-3; i++) {
        if (s.substr(i, 4) == "girl") {
            gn += 1;
            s[i] = s[i+1] = s[i+2] = s[i+3] = '.';
        }
    }

    // 查询三字符组合
    for (int i = 0; i < s.length()-2; i++) {
        if (s.substr(i, 3) == "gir") {
            gn += 1;
            s[i] = s[i+1] = s[i+2] = '.';
        } else if (s.substr(i, 3) == "irl") {
            gn += 1;
            s[i] = s[i+1] = s[i+2] = '.';
        } else if (s.substr(i, 3) == "boy") {
            bn += 1;
            s[i] = s[i+1] = s[i+2] = '.';
        } 
    }

    // 查询二字符组合
    for (int i = 0; i < s.length()-1; i++) {
        if (s.substr(i, 2) == "bo") {
            bn += 1;
            s[i] = s[i+1] = '.';
        } else if (s.substr(i, 2) == "oy") {
            bn += 1;
            s[i] = s[i+1] = '.';
        } else if (s.substr(i, 2) == "gi") {
            gn += 1;
            s[i] = s[i+1] = '.';
        } else if (s.substr(i, 2) == "ir") {
            gn += 1;
            s[i] = s[i+1] = '.';
        } else if (s.substr(i, 2) == "rl") {
            gn += 1;
            s[i] = s[i+1] = '.';
        }
    }

    // 查询单字符组合
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == 'b') {
            bn += 1;
            s[i] = '.';
        } else if (s[i] == 'o') {
            bn += 1;
            s[i] = '.';
        } else if (s[i] == 'y') {
            bn += 1;
            s[i] = '.';
        }  else if (s[i] == 'g') {
            gn += 1;
            s[i] = '.';
        }  else if (s[i] == 'i') {
            gn += 1;
            s[i] = '.';
        }  else if (s[i] == 'r') {
            gn += 1;
            s[i] = '.';
        }  else if (s[i] == 'l') {
            gn += 1;
            s[i] = '.';
        } 
    }
    
    cout << bn << endl << gn << endl;

    return 0;
}
```

思路很明了：先查询四个字符的gril子串，然后抹去（防止后续重复匹配）；接着查询三个字符的boy和gir,irl，然后同样抹去，以此类推…这样写的程序代码逻辑大量重复，循环次数很多，是很不推荐的方案，甚至一度因为for的结束位置不正确，导致答案错误：

![](20251119195150552.png)

## 3.优解

和一位同学聊到这题，他给出了更好的解决方案：

```cpp
#include <iostream>
using namespace std;

int main(void) {
    string s;
    cin >> s;
    int bn = 0;
    int gn = 0;

    for (int i = 0; i < s.length(); i++) {
        if (s[i] == 'b' || s[i+1] == 'o' || + s[i+2] == 'y') bn++;
        if (s[i] == 'g' || s[i+1] == 'i' || + s[i+2] == 'r' || + s[i+3] == 'l') gn++;
    }
    
    cout << bn << endl << gn << endl;
    
    return 0;
}
```

反思：由于题目中强调“每个单词至少有一个字符没有被覆盖”，那么在进行查询时，只需匹配到至少有一个位置、字符均正确的字母，即可判定这里有一个单词（如查询到其中三个字符为b--,-o-,--y,bo-,boy等，均可认为这里是一个（被覆盖的）boy单词）。这样一来，只需要进行一轮遍历即可，无需考虑四字符、三字符、二字符的一轮轮匹配。逻辑大大简化的同时，很大程度上减小了代码编写出错的可能性，也体现了我思想的局限性和算法水平的孱弱😢

# 二、[P3741 小果的键盘](https://www.luogu.com.cn/problem/P3741)

## 1.原题

原题链接： https://www.luogu.com.cn/problem/P3741

> **题目背景**
> 小果有一个只有两个键的键盘。
> **题目描述**
> 一天，她打出了一个只有这两个字符的字符串。当这个字符串里含有 VK 这个字符串的时候，小果就特别喜欢这个字符串。所以，她想改变至多一个字符（或者不做任何改变）来最大化这个字符串内 VK 出现的次数。给出原来的字符串，请计算她最多能使这个字符串内出现多少次 VK（只有当 V 和 K 正好相邻时，我们认为出现了 VK。）
> **输入格式**
> 第一行给出一个数字 n，代表字符串的长度。
> 第二行给出一个字符串 s。
> **输出格式**
> 第一行输出一个整数代表所求答案。
> **输入输出样例**
> **输入 #1**
> 2
> VK
> **输出 #1**
> 1
> **输入 #2**
> 2
> VV
> **输出 #2**
> 1
> **输入 #3**
> 1
> V
> **输出 #3**
> 0
> **输入 #4**
> 20
> VKKKKKKKKKVVVVVVVVVK
> **输出 #4**
> 3
> **输入 #5**
> 4
> KVKV
> **输出 #5**
> 1
> **说明/提示**
> 对于 100\% 的数据，$1\le n\le 100$。

## 2.错解

```cpp
#include <iostream>
using namespace std;
int main(void) {
    int n;
    string s;
    cin >> n;
    cin.ignore();
    int times = 0;
    bool find = false;
    getline(cin, s);
    if (n < 2) {
        cout << 0;
        return 0;
    }
    for (int i = 0; i < n-1; i++) {
        if (s[i] == 'V' && s[i+1] == 'K') {
            times += 1;
        }
    }
    for (int i = 0; i < n-3; i++) {
        if ((s[i] == 'K' && s[i+1] == 'K' && s[i+2]=='K') || (s[i] == 'V' && s[i+1] == 'V' && s[i+2]=='V')) {
            if (!find) {
                times += 1;
                find = true;
            }
        }
    }
    cout << times;
	
    return 0;
}
```

前一段的VK判断问题不大，但是对于“想改变至多一个字符（或者不做任何改变）来最大化这个字符串内 VK 出现的次数”的处理不够好，这里我认为只有"VVV"、"KKK"这样的子串才可以通过一次修改实现多一个VK组合（不适合只判断VV或KK，因为如果是VVK、VKK都已经算过一次VK，只匹配VV/KK会导致重复）。

逻辑上似乎没有问题，但是几乎无法通过任何一个测试点…一开始for循环中使用`s.length()`计算长度，在VS Code中可以正常输出答案，但是使用洛谷判题的结果是<font color="#6425d0">RE</font>，怀疑为数组越界，改为使用输入的参数`n`，即使VS Code中能运行出正确答案，洛谷中之前RE的测试点均显示<font color="#ff0000">WA</font>，输出的结果是0而不是正确答案（见下图）

![](20251119202722376.png)

（这个问题我到现在都没想明白，还请各位大佬不吝指教，小弟不胜感激）

## 3.优解

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int countVK(const string& s) {
    int cnt = 0;
    for (int i = 0; i < s.size() - 1; ++i)
        if (s[i] == 'V' && s[i+1] == 'K')
            ++cnt;
    return cnt;
}

int main() {
    int n;
    string s;
    cin >> n >> s;

    int maxVK = countVK(s);  // 先统计不改的情况

    for (int i = 0; i < n; ++i) {
        char original = s[i];
        // 尝试改成另一种字符
        s[i] = (original == 'V') ? 'K' : 'V';
        maxVK = max(maxVK, countVK(s));
        s[i] = original;  // 恢复
    }

    cout << maxVK << endl;
    return 0;
}
```

看了KIMI的方案，我才发现其实无需考虑到底替换哪一个字符，只需要逐个都翻转一遍，然后取最大的VK数量即可…核心逻辑是这一句：

```cpp
s[i] = (original == 'V') ? 'K' : 'V';
```

这一句搭配上外层的for循环，将输入的字符串的每个字符都翻转一下，然后找出VK的数量，如果多于之前，那么这就是更改一个字符之后，最多的VK数量。

# 三、总结反思

上面两道题，我自己写的差解/错解都体现出代码重复度高、手写了多个for循环的问题，主要原因在于**没有对题目进行充分的思考，刚读完题目就凭感觉直接写，没有体会到对字符串操作中的相同/相似的操作**，即程序化的思维还是不够，很多情况下想得太“死”了，程序不够灵活，对于条件比较模糊的查询，处理得不够灵活。

# 四、AI总结（by KIMI）

你其实已经把自己的“卡点”说得八九不离十了，只是还缺一张“思维解剖图”。  下面我把你两次踩坑的全过程拆成 4 个层层递进的“思维盲区”，每个盲区都给出“当时你是怎么想的 → 为什么想歪了 → 正确的大脑动作应该是什么 → 一句话口诀”。看完你就能对照出自己的“肌肉记忆”缺在哪一块，下次在字符串题里自动触发“优解”模式。

1. 盲区 A：把“覆盖”理解成“擦除”  
    当时：先找完整单词，找到后立刻 `= '.'`，生怕重复统计。  
    歪因：把“覆盖”脑补成“必须把旧字母涂掉才能不重复”，于是陷入“先长后短”的贪心模拟。  
    正解：题目只要求“至少有一个字符幸存”，反过来等价于“只要某 3 个连续位置能拼出 b-o-y 的任意一个排列，就算一个 boy”。  
    口诀：**“覆盖=或，不是与；只要对上位，不必清现场。”**

2. 盲区 B：把“模糊匹配”翻译成“多级精确匹配”  
    当时：4 连 → 3 连 → 2 连 → 单字符，一层层“降级”。  
    歪因：大脑默认“越精确越放心”，于是用 4 套 `if` 手工降级。  
    正解：既然只要命中 1 个字母就能证明“这里曾经有个单词”，那么  
    boy 只需 `b||o||y`，girl 只需 `g||i||r||l`，一次滑动窗口搞定。  
    口诀：**“能或就别与，能一次就别分层。”**

3. 盲区 C：把“至多改一次”理解成“必须找最佳位置”  
    当时：拼命想“到底改哪才赚”，于是去判断 VVV、KKK 这类局部特征。  
    歪因：把“最优”提前钉死在“规则推导”上，忘了计算机最不怕暴力。  
    正解：字符串只有 100 字符，枚举 100 次翻转 → 重新统计 → `max`，O(n²) 依旧 1e4 量级。  
    口诀：**“人怕暴力，机器不怕；先写暴力，再谈优化。”**

4. 盲区 D：代码一重复，就立刻“复制粘贴”而不是“升维抽象”  
    当时：看到 4→3→2→1 层，就顺手 `Ctrl-C/Ctrl-V`。  
    歪因：大脑“短期内存”不够，只好用文本长度换思维长度。  
    正解：只要发现“同构逻辑”>2 次，立刻升维：
    - 把“计数器+窗口”包成 `countVK(s)`；
    - 把“翻转→统计→恢复”包成“枚举+反悔”。  
        口诀：**“三次复制必抽象，两次相似必封装。”**

一张图总结你的“思维漏洞链”

```
读题─────→ 覆盖→擦除 → 多级匹配 → 最佳位推导 → 复制粘贴
         ↘(盲区A)  ↘(盲区B)   ↘(盲区C)    ↘(盲区D)
```

任何一步如果能立刻用上面 4 句口诀自检，就能在 30 秒内把“差解”扳成“优解”。

给你 1 个“字符串专题”通用 checklist，以后做题按顺序打钩，就不会再掉坑：

1. 读题时把“约束”转译成“等价条件”：  
    “至少一个字符幸存” ↔ “只要对上位就 ++”。
2. 先想“能不能或”，再想“要不要分层”：  
    只要允许“部分命中”，优先写“滑动窗口+或逻辑”。
3. 数据范围≤1e4 直接写暴力：  
    100 次翻转、255 次扫描，对 CPU 来说都是一眨眼。
4. 同一行代码出现 3 次，立刻拉函数：  
    让“思维长度”代替“文本长度”。

把这 4 步贴成便签放显示器，下次再看到字符串题，大脑就会先弹出“或逻辑+暴力枚举+函数封装”的三连，优解自然就蹦出来了。