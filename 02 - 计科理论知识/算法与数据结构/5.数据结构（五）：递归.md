---

---
--- 
> 声明：本篇笔记摘自[《数据结构教程》 - 清华大学出版社](http://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC5%E7%89%88%EF%BC%89/22216268?fromModule=search-result_lemma)，遵循[CC BY 4.0协议](https://creativecommons.org/licenses/by/4.0/legalcode.zh-hans)。
> 存在由AI生成的小部分内容，仅供参考，请仔细甄别可能存在的错误。
--- 
# 一、什么是递归

## 1.递归的定义

- **递归**：在一个函数中直接调用函数本身的成分（直接递归）
	- **间接递归**：p调用了q，然后q又调用了p
- 递归算法通常把大问题化为多个类似的小问题来求解。

能够使用递归解决的问题一般具有这几个特点：
- 总的大问题可以转化为一个或多个子问题来求解，这些子问题的求解方法与原来的大问题是完全相同的，只是数量规模上不同
- 递归调用的次数是有限的
- 有明确的递归终止条件（递归出口）

--- 
例：经典的求阶乘算法：
```cpp
int factorial(int n) {
	if (n == 1) {                  // 明确的递归出口
		return 1;
	} else {
		return n * factorial(n-1); // 递归调用本身
	}
}
```
--- 
## 2.使用递归的时机

### ① 定义是递归的

一些数学公式、数列的定义本身就是基于递归的，如给出$a_n$和$a_{n+1}$的关系。这样在求第n项或者前n项和时，理所当然地可以使用递归来很方便地进行计算。

--- 
例：求斐波那契数列
```cpp
int fibl(int n) {
	if (n == 1 || n == 2) {
		return 1;                       // 递归出口
	} else {
		return fibl(n-1) + filb(n-2);   // 递归调用本身
	}
}
```
--- 
### ② 数据结构是递归的

有些数据结构的定义就是递归的，如之前的链表、链栈、链队的类型声明：
```cpp
typedef struct LNode {
	ElemType data;        // 数据域
	struct LNode *next;   // 指向下一个同类型结点的指针
} LinkNode
```

结构体LNode的声明中，使用了本身 `struct LNode` 来定义一个指向和自己相同类型的结点的指针，是一种递归的声明。

对于这样的数据结构，采用递归来编写算法是很方便高效的：

--- 
例：求不带头结点的单链表中所有元素的数据域之和：
```cpp
int sum(LinkNode *L) {
	if (L==NULL) {
		return 0;
	} else {
		return (L->data + Sum(L->next));
	}
}
```
--- 
### ③ 问题的求解方法是递归的

典型的例如汉诺塔问题，就可以使用递归来方便地求解：

- 想要把x个盘子从A经过B移动到C上：
	- 先把x-1个盘子从A经过C移动到B上
	- 然后将第x个（也就是底下最大的）盘子从A移动到C上
- 现在的问题是将x-1个盘子从B经过A移动到C上
	- 先将x-2个盘子从B经过C移动到A上
	- 然后将第x-1个盘子从B移动到C上
- 于是完成了最底下两个盘子的移动。继续进行这样的操作，直到所有的盘子都移动到了C上

得到的Hanoil算法如下：

```cpp
#include <cstdio>

void Hanoil(int n, char X, char Y, char Z) {
	if (n == 1) {
		printf("将第%d个盘子从%c移动到%c\n\n", n, X, Z);   // 只剩下最大的一个盘子，直接移动到Z柱
	} else {
		Hanoil(n-1, X, Z, Y);
		printf("将第%d个盘子从%c移动到%c\n", n, X, Z);
		Hanoil(n-1, Y, X, Z);
	}
}

int main(void) {
    Hanoil(5, 'A', 'B', 'C');
    return 0;
}
```

运行程序，输出了具体的操作步骤：

```text
将第1个盘子从A移动到C
将第2个盘子从A移动到B
将第1个盘子从C移动到B
将第3个盘子从A移动到C
将第1个盘子从B移动到A
将第2个盘子从B移动到C
将第1个盘子从A移动到C
将第4个盘子从A移动到B
将第1个盘子从C移动到B
将第2个盘子从C移动到A
将第1个盘子从B移动到A
将第3个盘子从C移动到B
将第1个盘子从A移动到C
将第2个盘子从A移动到B
将第1个盘子从C移动到B
将第5个盘子从A移动到C
将第1个盘子从B移动到A
将第2个盘子从B移动到C
将第1个盘子从A移动到C
将第3个盘子从B移动到A
将第1个盘子从C移动到B
将第2个盘子从C移动到A
将第1个盘子从B移动到A
将第4个盘子从B移动到C
将第1个盘子从A移动到C
将第2个盘子从A移动到B
将第1个盘子从C移动到B
将第3个盘子从A移动到C
将第1个盘子从B移动到A
将第2个盘子从B移动到C
将第1个盘子从A移动到C
```

## 3. 递归模型

观察上面的几个递归算法，可以总结出一些共性：

- **递归出口**：确定递归到何处结束
- **递归体**：确定递归时的递推关系

```cpp
void 函数名(形参表) {
	if (n等于某个值) {
		return 某个值；                      // 递归出口
	} else {
		return 调用函数名(形参表)继续进行操作   // 递归体	
	}
}

```

## 二、栈和递归

## 1.函数调用栈

- 大多数CPU上的程序，都使用**栈**来支持函数的调用操作
- **栈帧**：单个函数调用操作所使用的函数调用栈
- 每次调用函数的过程：
	- 创建一个帧，保存函数实参、返回地址和局部变量等信息
	- 将这一帧压入调用栈中
	- 如果在返回值之前有新的调用，同样将与新函数对应的一帧进栈，成为栈顶
	- 函数调用完成之后将对应的帧出栈，根据返回地址回到程序运行处继续运行
## 2.递归调用的实现

每次递归调用函数时，每个函数调用“复印件”的实参、局部变量的值都可能不相同，因此需要使用栈来存储和处理。
- 系统为每次调用开辟一组内存空间，来存储返回值地址和函数的参数值、被中断的局部变量等
- 每调用一次函数就将函数的这些数据进栈
- 函数返回值时将对应的一组数据出栈，恢复之前遇到新的调用时被中断的函数调用，继续运行下去
## 3.递归的时空性能分析

递归算法的时空性能分析属于**变长时空分析**，与非递归的定长分析不同，需要采取新的分析方法：

#### ① 时间复杂度分析

先设函数本身的时间复杂度为T(n)，根据递归函数的定义和递推关系，写出T(n)的表达式后，求出几项的值，观察得出T(n)与n的规律，写出其关于n的表达式，最后取最高次项即可。

例如对于之前的汉诺塔算法：

```cpp
void Hanoil(int n, char X, char Y, char Z) {
	if (n == 1) {
		printf("将第%d个盘子从%c移动到%c\n\n", n, X, Z);   // 只剩下最大的一个盘子，直接移动到Z柱
	} else {
		Hanoil(n-1, X, Z, Y);
		printf("将第%d个盘子从%c移动到%c\n", n, X, Z);
		Hanoil(n-1, Y, X, Z);
	}
}
```

假设执行一次`Hanoil(n, X, Z, Y);`的时间为`T(n)`，按照代码逻辑可以列出T(n)的递推表达式：

```text
当n为1时, T(n) = 1               // 只执行一次输出操作，是常数级别的
否则    , T(n) = 2 * T(n-1) + 1  // 递归调用了两次n-1规模的自身函数，另外执行了一次常数级的输出操作
```

于是可以得到：
- T(1) = 1
- T(2) = 2 * T(1) + 1 = 3
- T(3) = 2 * T(2) + 1 = 7
- T(n) = $2^n-1$

故此算法的时间复杂度为O($2^n$)  \[时空复杂度只保留最高次]。

#### ② 空间复杂度分析

分析过程与时间复杂度类似，也是找递推关系然后求出表达式。

例如，对前面的汉诺塔算法进行分析：

设执行一次`Hanoil(n, X, Z, Y);`使用的空间为`S(n)`，写出S(n)的表达式：

```cpp
s(n) = 1
s(n) = s(n-1) + 1 // 虽然执行了两次n-1规模的递归，但是前一次子问题结束后会被释放，这里只需要记一次即可 
```


于是可以得到：
- T(1) = 1
- T(2) = T(1) + 1 = 2
- T(3) = T(2) + 1 = 3
- T(n) = $n$

故此算法的时间复杂度为O($n$) 。


#### ③ “时间”与“空间”的比较

需要注意的是，时间不可以复用，但是空间可以：

- **时间（$T(n)$）好比“搬砖”**：先搬了 $T(n-1)$ 块砖，又搬了 1 块，最后又搬了 $T(n-1)$ 块砖。一共出的力气是累加的，搬过的砖不能“取消”。所以是 $2T(n-1) + 1$。
- **空间（$S(n)$）好比“爬梯子”**：先爬上 $n-1$ 级台阶，下来后，再去爬另一段同样的 $n-1$ 级台阶。虽然爬了两次，但**最高的时候离地面只有 $n$ 级台阶的高度**。不需要两个梯子，同一个梯子爬两次即可。
