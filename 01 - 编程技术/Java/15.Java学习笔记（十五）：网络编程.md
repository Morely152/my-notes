---

---
--- 
> 声明：本篇笔记部分摘自[《Java核心技术（卷Ⅰ） - 机械工业出版社》](https://detail.tmall.com/item.htm?ali_refid=a3_420434_1006%3A1151895243%3AN%3AoB1xLXSDdjSpCunkFwpZbCtvD%2B6YEaA9%3A39f8fcdda956d1ec63523e9a6e9e2355&id=708821240842&mi_id=0000mg2-P7Ustbzeym2_6DxuUMLCpndkVCAGc5EaA_l8QQ0&mm_sceneid=1_0_128421313_0&priceTId=2147831a17554253371677975e1dca&spm=a21n57.1.hoverItem.2&utparam=%7B%22aplus_abtest%22%3A%226b956865e0df43cd4a6620880d877f11%22%7D&xxc=ad_ztc)及[Java教程-廖雪峰-2025-06-16](https://liaoxuefeng.com/books/java/introduction/index.html)，遵循[CC BY 4.0协议](https://creativecommons.org/licenses/by/4.0/legalcode.zh-hans)。
> 存在由AI生成的小部分内容，仅供参考，请仔细甄别可能存在的错误。
--- 
# 一、网络编程基础

在进行简单的应用开发时，我们或许能在本地完成所有的任务。但是当我们需要实现用户之间的交互（实时排行榜、即时聊天等），或者需要对用户进行管理（账户系统、消息推送等），我们就需要实现能够通过计算机网络通信的程序了，即我们需要实现网络编程。

在同一个网络中，如果两台设备使用的是同一种协议，那么它们就可以相互通信。很多个小网络组成的大网络，即“网络的网络”，就是所谓的**互联网**。想要联入互联网与广泛的计算机设备通信交流，需要使用TCP/IP协议。

## 1.IP地址与基本网络知识

在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机必须要有一个IP地址，也可能有多个IP地址。

IP地址分为IPv4和IPv6两种。IPv4采用32位地址，类似`101.202.99.12`，而IPv6采用128位地址，类似`2001:0DA8:100A:0000:0000:1020:F2F3:1428`。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前几乎耗尽，而IPv6的地址数量很多，可以保障一段时间内的网络设备的分配。

IP地址又分为公网IP地址和内网IP地址。公网IP地址可以直接被访问，内网IP地址只能在内网访问。内网IP地址类似于：

- 192.168.x.x
- 10.x.x.x

有一个特殊的IP地址，称之为本机地址，它总是`127.0.0.1`。

如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址`127.0.0.1`，还有一个IP地址，例如`101.202.99.12`，可以通过这个IP地址接入网络。

要判断两台计算机是否在同一网络，只需要判断它们的**网络号**是否相同：

```text
网络号 = IP地址 ＆ 子网掩码
```

例如，某台计算机的IP是`101.202.99.2`，子网掩码是`255.255.255.0`，那么该计算机的网络号是`101.202.99.2 & 255.255.255.0 = 101.202.99.0`。如果计算得出另一台计算机的网络号与之相同，那么这两台计算机可以直接通过网线通信；如果不同，就需要路由器或者交换机（称之为网关）来间接通信。网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫路由。

一台计算机的一个网卡会有3个关键配置：

- IP地址
- 子网掩码
- 网关IP

在CMD中，执行命令`ipconfig`可以查询到详细的网络配置信息：

![](20250925151220587.png)

## 2.域名

直接记忆和输入域名访问网站比较麻烦，我们通常使用`www.xxxx.com`或`www.xxxx.cn`这样的一串字符，即**域名**来访问网站。当我们在浏览器中输入域名时，域名服务器（DNS, Domain Name Server）会将域名转换成对应的ip地址返回给路由器，然后路由器再通过这个ip地址访问对应的服务器。

想要通过域名知道服务器的ip，只需要ping一下就可以了：

![](20250925203913858.png)

本机域名为`localhost`，它对应的IPv4地址是`127.0.0.1`,IPv6地址是`::1`。

## 3.网络模型

计算机网络模型采用了分层模型，每一层负责处理自己的操作。由ISO组织定义的标准计算机互联模型OSI将网络划分成了下面六个层次：

- **应用层**：提供应用程序之间的通信；
- **表示层**：处理数据格式，加解密等等；
- **会话层**：负责建立和维护会话；
- **传输层**：负责提供端到端的可靠传输；
- **网络层**：负责根据目标地址选择路由来传输数据；
- **链路层和物理层**：负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。

互联网实际使用的TCP/IP协议大致对应了上面的5层模型，分别是应用层、传输层、IP层、网络接口层。

## 4.常用协议

IP、TCP、UDP这三种网络协议都是互联网的核心协议，分属于**TCP/IP 协议族**的不同层级，职责分工明确，共同支撑数据在网络中的传输。

### ① IP 协议（Internet Protocol，网际协议）

- **层级**：网络层（负责 “找路”）
- **核心作用**：给数据包分配 “目标地址”（IP 地址），并通过路由器将数据包从 “源设备” 转发到 “目标设备”，是实现跨网络通信的基础。
- **关键特点**：
    - 无连接：发送数据前不与目标设备建立连接，直接发送；
    - 不可靠：不保证数据包一定送达、不保证顺序（可能丢包、乱序），也不检查数据完整性；
    - 面向数据包：以 “IP 数据包” 为单位传输数据。
- **类比**：类似快递的 “地址单”—— 只负责标注收件地址，确保包裹被送到正确的城市 / 小区，但不保证包裹不丢失、不损坏，也不管包裹送达顺序。

### ② TCP 协议（Transmission Control Protocol，传输控制协议）

- **层级**：传输层（负责 “可靠传输”）
- **核心作用**：在 IP 协议的基础上，为应用程序（如浏览器、微信）提供**可靠、有序、双向**的数据传输服务，解决 IP 协议 “不可靠” 的问题。
- **关键特点**：
    - 面向连接：传输前需通过 “三次握手” 建立连接（类似打电话时 “喂 -> 请讲 -> 好的” 确认），传输后通过 “四次挥手” 断开连接；
    - 可靠传输：通过 “确认机制”（收到数据后回复 “已收到”）、“重传机制”（丢包后重新发送）、“流量控制”（避免发送过快导致接收方拥堵）、“拥塞控制”（避免网络整体拥堵），确保数据不丢、不重、有序；
    - 面向字节流：将应用数据拆分为字节流，按序传输，接收方再重组。
- **适用场景**：对可靠性要求高的场景，如网页浏览（HTTP/HTTPS）、文件下载（FTP）、即时通讯的消息发送、邮件传输（SMTP）等。

### ③ UDP 协议（User Datagram Protocol，用户数据报协议）

- **层级**：传输层（负责 “快速传输”）
- **核心作用**：在 IP 协议基础上，以 “最快速度” 传输数据，不保证可靠性，追求低延迟。
- **关键特点**：
    - 无连接：无需建立 / 断开连接，直接发送数据，效率高；
    - 不可靠：不确认、不重传、不保证顺序，丢包风险高；
    - 面向数据报：数据以 “UDP 数据报” 为单位，直接发送，头部简单（仅 8 字节），开销小、速度快。
- **适用场景**：对延迟敏感、可接受少量丢包的场景，如视频通话（Zoom）、直播、游戏、实时语音（微信语音）、DNS 域名解析等。


下表是这三者的简单对比：

|协议|层级|核心能力|可靠性|速度|典型应用|
|---|---|---|---|---|---|
|IP|网络层|跨网络 “找路”（地址转发）|低|中等|所有互联网数据的基础转发|
|TCP|传输层|可靠、有序传输|高|中等|网页、文件下载、消息|
|UDP|传输层|快速、低延迟传输|低|高|视频通话、游戏、直播|

## 5.Socket套接字

Socket（套接字）是**实现网络中不同设备间进程通信的技术 / 编程接口**，是 TCP/IP 协议族在应用层的 “桥梁”—— 它封装了底层 TCP/UDP、IP 协议的复杂细节，让开发者无需直接操作协议栈，就能轻松编写客户端与服务器的通信代码。

### 核心本质：“通信的端点”

可以把 Socket 理解为网络通信中的 “电话”：

- 两台设备（如手机和微信服务器）要通信，需各自创建一个 Socket 作为 “通信端点”；
- 客户端通过自己的 Socket，向服务器的 Socket 发起连接 / 发送数据；
- 服务器通过自己的 Socket，接收连接 / 数据，再回传响应。

一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP/IP协议把数据传输到网络：

```
┌───────────┐                                ┌───────────┐
│Application│                                │Application│
├───────────┤                                ├───────────┤
│  Socket   │                                │  Socket   │
├───────────┤                                ├───────────┤
│    TCP    │                                │    TCP    │
├───────────┤     ┌──────┐      ┌──────┐     ├───────────┤
│    IP     │◀───▶│Router│◀────▶│Router│◀───▶│    IP     │
└───────────┘     └──────┘      └──────┘     └───────────┘
```

仅仅通过IP地址进行通信是不够的，同一台计算机同一时间会运行多个网络应用程序，例如浏览器、QQ、邮件客户端等。当操作系统接收到一个数据包的时候，如果只有IP地址，它没法判断应该发给哪个应用程序，所以，操作系统抽象出Socket接口，每个应用程序需要各自对应到不同的Socket，数据包才能根据Socket正确地发到对应的应用程序。

Socket由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为**IP地址加端口号**。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于**特权端口**，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。

使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当**服务器端**，它会主动监听某个指定的端口，另一个进程必须充当**客户端**，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了连接，双方后续就可以随时发送和接收数据。

因此，当Socket连接成功地在服务器端和客户端之间建立后：

- 对服务器端来说，它的Socket是服务器IP地址和指定的端口号；
- 对客户端来说，它的Socket是用户计算机的IP地址和一个由操作系统分配的随机端口号。

# 二、TCP编程

## 1.服务器端

TCP编程，顾名思义是编写基于TCP协议实现的网络程序。Java标准库提供了`ServerSocket`来实现监听指定IP的指定端口。通过`ServerSocket ss = new ServerSocket(端口号)`来监听计算机上所有网络接口的指定端口；若监听成功则通过无限循环来处理客户端的连接：

```java
while(true) {
	Socket socket = ss.accept();
	
	Thread t = new Handler(socket);
	t.start();
}
```

代码`ss.accept()`表示每当有新的客户端连接进来后，就返回一个`Socket`实例，这个`Socket`实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，我们就必须为每个新的`Socket`创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理,具体的处理逻辑写在子线程的`run()`方法中。这里也可以使用线程池来提高处理效率：

```java
// 创建一个线程池 (固定大小为100)
ExecutorService es = Executors.newFixedThreadPool(100);

while (true) {
    Socket socket = ss.accept();

    // 将任务提交给线程池处理，而非每次都创建新线程
    es.submit(new Handler(socket));
}
```

如果没有客户端连接进来，`accept()`方法会阻塞并一直等待。如果有多个客户端同时连接进来，`ServerSocket`会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用`accept()`就可以获取新的连接。

根据上面的分析，我们可以写出一个比较完整的TCP程序，实现监听`localhost:6606`并且输出用户端输入的内容：

```java
import java.io.*;  
import java.net.*;  
  
public class Demo {  
    public static void main(String[] args) {  
        int port = 6606;  
  
        try (ServerSocket serverSocket = new ServerSocket(port)) {  
            System.out.println("服务端启动，监听端口: " + port);  
  
            // 循环接受多个客户端连接（避免接收一次就退出）  
            while (true) {  
                Socket clientSocket = serverSocket.accept();  
                System.out.println("客户端连接成功: " + clientSocket.getInetAddress());  
  
                // 1. 读取APIfox发送的请求数据（基于字节流）  
                try (InputStream in = clientSocket.getInputStream();  
                     // 2. 新增：向APIfox发送响应数据的输出流  
                     OutputStream out = clientSocket.getOutputStream()) {  
  
                    byte[] buffer = new byte[1024]; // 1KB缓冲区，可根据数据大小调整  
                    int bytesRead = in.read(buffer); // 读取APIfox发送的数据  
  
                    if (bytesRead > 0) {  
                        // 将字节数组转换为字符串（注意编码要和APIfox一致，默认UTF-8）  
                        String receivedData = new String(buffer, 0, bytesRead, "UTF-8");  
                        System.out.println("Server: Accept data OK: " + receivedData);  
  
                        // ---------------- 核心新增：发送响应给APIfox ----------------  
                        String response = "Server: Receive data OK！"; // 响应内容  
                        // 将响应字符串转为字节流，写入输出流（发送给APIfox）  
                        out.write(response.getBytes("UTF-8"));  
                        out.flush(); // 强制刷新缓冲区，确保响应立即发送（避免滞留）  
                    }  
  
                } catch (IOException e) {  
                    e.printStackTrace();  
                } finally {  
                    // 关闭客户端连接（一次请求-响应后断开，符合调试场景）  
                    clientSocket.close();  
                    System.out.println("客户端连接已关闭");  
                }  
            }  
  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}
```