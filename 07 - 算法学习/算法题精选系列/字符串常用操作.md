---

---
--- 
## 0.读取指定行数的字符串

记得使用`cin.ignore()`忽略掉换行符，避免被getline捕获到：

```cpp
int n;
cin >> n;
cin.ignore();   // 重要：忽略掉换行符，避免被getline捕获到！
string line;

while (n--) {
	getline(cin, line);
}
```

## 1.读取大小未知的方阵，存储到一维数组中

通过`getline(cin, string)`接收整行输入，然后拆分到数组中：

``` CPP
int map[200] = {0};
string line;
int index = 0;

// 读取首行，推算方阵的大小
getline(cin, line);
n = line.length();

// 处理首行
for(int i = 0; i < n; i++) {
	map[index++] = line[i] - '0';
}

// 处理剩余的n-1行
for (int i = 1; i < n; i++) {
	getline(cin, line);
	for (int j = 0; j < n; j++) {
		map[index++] = line[j] - '0';
	}
}
```

## 2.读取不定长的矩阵

根据`string.isEmpty()`，把空行作为输入结束的判断,将每一行输入存储到vector中：

```CPP
#include <vector>

string line;
vector<string> lines;
int n = 0;

	// 读取所有行直到空行或EOF
while (getline(cin, line)) {
	if (line.empty()) break; // 空行表示输入结束
	lines.push_back(line);
}
```

## 3.遍历字符串

使用for循环，通过计数变量的值与字符串长度比较实现：

``` cpp
// 传统for循环写法：
for (int i = 0; i < str.size(); i++) {
	cout << str[i] << " ";
}

// 范围for循环
for (auto s : str) {
	cout << s;
}
```

## 4.凯撒密码（防溢出右移）

输入`s`字符串，右移`n`次，超过z的回到a：

```cpp
for (int i = 0; i < s.size(); i++) {
	printf("%c", (s[i] - 'a' + n) % 26 + 'a');
}
```


## 5.字符串与整数的转换

``` cpp
// 字符串 -> 数字：直接使用数学运算
string str;
int num = 0;
for (auto s : str) {
	num = num * 10 + (s - '0');
}

// 数字 ->字符串：to_string()方法
#include <cstring>
int a, b;
cin >> a >> b;
string res = to_string(a) + "+" to_string(b) + '=' + to_string(a+b)；
cout << res;
```

## 6.统计字符串中不含空格、换行符的字符数

```cpp
string line;
getline(cin, line);

int cnt = line.length();

for (int i = 0; i < line.length(); i++) {
	if (line[i] == ' ') {
		cnt -= 1;
	}
}

cout << cnt;
```

## 7.文章中的单词查询

将带查询单词进行**预处理**，先在两头加上空格（类似于`" set "`），可以防止识别到单词中的一部分（如`"reset"`），同时将文章中所有的大写字母转换成小写，并且在文章前后也加上空格，防止查询不到首尾单词。

预处理工作：

```cpp
// 先给一个空格，再接受输入的单词或者文章，最后输出一个空格
string word = " ";
string passage = " ";
string temp;

getline(cin, temp);
word += temp += " ";
getline(cin, temp);
passage += temp += " ";

// 小写化处理,这里由于要修改字符串的内容，需要直接引用而不是值拷贝
for (char& ch : passage) {
	if (ch > 'A' && ch < 'Z') {
		ch = 'a' + (ch - 'A');
	}
}
for (char& ch : word) {
	if (ch > 'A' && ch < 'Z') {
		ch = 'a' + (ch - 'A');
	}
}
```

查询单词出现次数：

```cpp
int cnt = 0;
for (int i = 0; i < passage.length(); i++) {
	if (passage.substr(i, word.length()) == word) {
		cnt++;
	}
}
```

查询单词出现的第一个位置：

```cpp
size_t tar = passage.find(word);
if (tar != string::npos) { // 不记得这样写，也可以通过上面的cnt为0判定不存在子串
	cout << tar << endl;
} else {
	cout << -1 << endl;
}
```

## 8.类似于Word的模拟文字编辑软件

```CPP
#include <iostream>
#include <string>
using namespace std;

int main() {
    
    // 读取操作次数和初始字符串
    int q;
    string doc;
    cin >> q;
    cin >> doc;
    
    while (q--) {
        int op;
        cin >> op;
        
        if (op == 1) {
            // 操作1：直接尾插，使用+=运算符即可
            string str;
            cin >> str;
            doc += str;
            cout << doc << endl;
        } else if (op == 2) {
            // 操作2：截取部分，获取从第a个字符开始，长度为b的子串
            int a, b;
            cin >> a >> b;
            doc = doc.substr(a, b);
            cout << doc << endl;
        } else if (op == 3) {
            // 操作3：在第a个字符处插入一个字符串
            int a;
            string str;
            cin >> a >> str;
            doc.insert(a, str);
            cout << doc << endl;
        } else if (op == 4) {
            // 操作4：查找字符串中的子串，返回字串首字符的位置
            string str;
            cin >> str;
            size_t pos = doc.find(str);
            if (pos != string::npos) {
                cout << pos << endl;
            } else {
                cout << -1 << endl;
            }
        }
    }
    
    return 0;
}
```

## 9.重定向输入输出到文件中，而不是从控制台读写

```cpp
// 放在main函数前面即可
freopen("title.in", "r", stdin);
freopen("title.out", "w", stdout);
```

