---

---
--- 
> 声明：本篇笔记摘自[《数据结构教程》 - 清华大学出版社](http://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC5%E7%89%88%EF%BC%89/22216268?fromModule=search-result_lemma)，遵循[CC BY 4.0协议](https://creativecommons.org/licenses/by/4.0/legalcode.zh-hans)。
> 存在由AI生成的小部分内容，仅供参考，请仔细甄别可能存在的错误。
--- 
# 一、基本概念

- **串**：是由零个或多个字符组成的有限序列。
- 通常将串表示成"$a_1a_2a_3...a_n$"的形式，外侧的**双引号**是串的标志。
- 两个串**相等**：当且仅当两个串长度相等且每个对应位置的字符都相等。
- 一个串中，任意个连续字符组成的序列称为**子串**。

串的ADT定义如下：
```ADT
ADT String
{
    数据对象：
	    D = { a[i] | 1 <= i <= n, n >= 0, a[i] 为 char 类型 }
    数据关系：
	    R = { <a[i], a[i+1]> | a[i], a[i+1] ∈ D, i = 1, ..., n-1 }
    基本运算：
	    StrAssign(&s, cstr): 生成值等于cstr的串s。
	    DestroyStr(&s): 销毁串, 释放为串s分配的存储空间。
	    StrCopy(&s, t): 串复制, 将串t赋给串s。
	    StrEqual(s, t): 判断串是否相等, 若两个串s与t相等则返回真。
	    StrLength(s): 求串长, 返回串s中字符的个数。
	    Concat(s, t): 串连接, 返回由两个串s和t连接在一起形成的新串。
	    SubStr(s, i, j): 求子串, 返回串s中从第i个字符开始的由连续j个字符组成的子串。
	    InsStr(s1, i, s2): 子串的插入, 将串s2插入串s1的第i个位置, 并返回产生的新串。
	    DelStr(s, i, j): 子串的删除, 从串s中删去从第i个字符开始的长度为j的子串, 并返回产生的新串。
	    RepStr(s, i, j, t): 子串的替换, 在串s中将从第i个字符开始的j个字符构成的子串用串t替换, 并返回产生的新串。
	    DispStr(s): 串的输出, 输出串s的所有字符值。
}
```

# 二、存储结构

## 1.顺序串

顺序串与顺序表类似，其中的字符被存储在一串连续的存储单元中，类型声明如下：

```cpp
typedef struct {
	char data[MaxSize];
	int length;
} SqString;
```

顺序串的插入算法如下,其他算法的设计与顺序表相似：

```cpp
SqString InsStr(SqString s1, int i, SqString s2)
{
    int j;
    SqString str;                           //定义结果串
    str.length = 0;                         //设置 str 为空串
    if (i <= 0 || i > s1.length + 1)        //参数不正确时返回空串
        return str;
    for (j = 0; j < i - 1; j++)             //s1.data[0..i-2]->str
        str.data[j] = s1.data[j];
    for (j = 0; j < s2.length; j++)         //s2.data[0..s2.length-1]->str
        str.data[i + j - 1] = s2.data[j];
    for (j = i - 1; j < s1.length; j++)     //s1.data[i-1..s1.length-1]->str
        str.data[s2.length + j] = s1.data[j];
    str.length = s1.length + s2.length;
    return str;
}
```

## 2.链串

相应地，链串与链表相似，采用链式存储。略有不同的是链串中的一个结点也可以存储多个字符。
- **结点大小**：链串中每个结点存储的字符个数。
	- 对于链串来说，结点越大，存储密度越大，但相应算法设计也越麻烦。
- 这里规定结点大小均为1，即每个结点只存储一个字符。

链串的类型声明如下：
``` cpp
typedef struct snode {
	char data;                  // 数据域
	struct snode *next;         // 指针域
} LinkStrNode;
```

链串的算法设计与链表类似。求链串的子串的算法设计如下：
```cpp
LinkStrNode * SubStr(LinkStrNode *s, int i, int j) {
    int k;
    LinkStrNode *str, *p = s->next, *q, *r;
    str = (LinkStrNode *)malloc(sizeof(LinkStrNode));
    str->next = NULL;                                    // 将结果串str置为空串
    r = str;                                             // r指向结果串的尾结点
    if (i<1 || i>StrLength(s) || j<0 || i+j-1>StrLength(s)) // 参数错误返回空串
        return str;
    for (k=1;k<i;k++) {                                     // 找到第i个结点
        p = p->next;
    }               
    for(k=1; k <=j; k++) {                                  // 从i开始的j个字符，复制到str中
        q = (LinkStrNode *)malloc(sizeof(LinkStrNode));
        q->data = p->data;
        r->next=q;
        r = q;
        p = p->next;
    }
    r -> next = NULL;                                         // 封闭尾结点
    return str;
}
```
# 三、模式匹配

- **模式匹配**：在**目标串**s中找与**模式串**t相等的子串，找到一个即为匹配成功。
## 1.Brute-Force算法

又称BF算法、暴力算法、简单匹配算法，采取穷举的思想。

--- 
示例：从目标串 `aaaaab` 中找模式串 `aaab`，过程如下所示：
```text
s:aaaaab
t:aaab     // 匹配失败
t: aaab    // 匹配失败
t:  aaab   // 匹配成功
```
--- 
算法描述如下：
```cpp
int BF(SqString s, SqString t) {
	int i=0,j=0;                    
	while(i<s.length && j < t.length) {  // 两个串都没有完成遍历
		if(s.data[i] == t.data[j]) {     // 对应相同，继续往下比较
			i++;j++;
		} else {                         // 不相同：将模式串与目标串的下一位对齐开始比较
			i = i-j+1;j=0;               // 主串指针回溯到本次匹配开始位置的下一位。
		}
	}
	if (j >= t.length) {
		return(i-t.length);
	} else {
		return(-1);
	}
}
```

时间复杂度为O($m\times n$)。

## 2.KMP算法

简单匹配（BF）算法的问题在于，主串指针需要频繁回溯，降低了算法的效率。KMP（Knuth-Morris-Pratt）算法在消除主串指针的回溯上作出了优化，让模式匹配的算法效率得到了提高。

示例：求目标串 `ababbaabbaababaaacb` 能否与模式串 `ababaa` 匹配
（原视频：[KMP算法-超细超全讲解（上）原理篇 -- \_\_阿岳\_\_](https://www.bilibili.com/video/BV1UN4y1u7Nx)）

### ① 构造next数组

首先做一个辅助数组next，分别求出其中的元素`next[j]`

逐个考察 `ababaa` 中的字符，看它们前面的子串中最长的相同前后缀：

```text
模式串:     a b a b a a
一位前后缀： a         a   --> 对于整个模式串，最长相同前后缀为1
两位前后缀： a b     a a
```

- 对于第一个元素，前面的子串为空，规定记作-1

- 对于第二个元素，前面的子串为a:
	- 无前后缀 -> 0

- 对于第三个元素，前面的子串为ab
	- 一位：前缀a != 后缀b -> 0

- 对于第四个元素，前面的子串为aba
	- 一位：前缀a == 后缀a -> 1
	- 两位：前缀ab != 后缀ba

- 对于第五个元素，前面的子串为abab
	- 一位：前缀a != 后缀b
	- 两位：前缀ab == 后缀ab -> 2
	- 三位：前缀aba != 后缀bab

- 对于第六个元素，前面的子串为ababa
	- 一位：前缀a == 后缀a -> 1
	- 两位：前缀ab != 后缀ba
	- 三位：前缀aba == 后缀aba -> 3
	- 四位：前缀abab != 后缀baba

于是得到模式串 `t[] = "ababaa"` 的next数组如下：

|     j     |  0  |  1  |  2  |  3  |  4  |  5  |
| :-------: | :-: | :-: | :-: | :-: | :-: | :-: |
|  `t[j]`   |  a  |  b  |  a  |  b  |  a  |  a  |
| `next[j]` | -1  |  0  |  0  |  1  |  2  |  3  |

如果没看懂，这里给出对于 `next[5] = 3` 的再次解释：

- `next[5]`是多少，就看模式串对应的`t[5] = 'a'` 之前的子串 `ababa`:
	- 一位前后缀分别为a和a，相等
	- 二位前后缀分别为ab和ba，不相等
	- 三位前后缀分别为aba和aba，相等
	- 四位前后缀分别为abab和baba，不相等
- 于是最长的相同前后缀为3，即得出 `next[5] = 3`

### ② 根据next数组进行匹配

next数组的作用就是，当模式串中第j个字符与主串失配时，无需只挪动一位再从头开始比较。当失配发生时，先将模式串移动到左端与失配处对齐，然后向左移动`next[j]`个单位，可以保证j之前的元素都已经完成匹配，只需要继续往后看即可。

![](20260110001044087.jpg)

### ③ 对next数组的优化处理

为了尽量让模式串快速往右边移动，我们当然希望每次对齐失配处之后，往左回移的距离尽可能小，也就是让next数组中的数尽量小。因此我们考虑对其进行优化，得到更加高效的**nextVar数组**：

求 `nextVar[j]` 的规则：
- 与next数组相同，规定 `nextVar[0] = -1`
- 先看 `next[j]`，这里记作k，然后看模式串中的 `t[k]` 是什么字符
	- 如果这个字符和 `t[j]` 相同，那么 `nextVar[j] = next[k]`，即取前面和它字符相同的next的值
	- 如果不相同，那么 `nextVar[j] = next[j]`，即保持原来的next值不变
- 以下为图示，其中红色的相同（得到了优化），绿色的不同（保持原状）：
![](20260110001914646.png)
于是根据上面的规则，得到nextVal数组如下：

|      j       |  0  |  1  |  2  |  3  |  4  |  5  |
| :----------: | :-: | :-: | :-: | :-: | :-: | :-: |
|    `t[j]`    |  a  |  b  |  a  |  b  |  a  |  a  |
|  `next[j]`   | -1  |  0  |  0  |  1  |  2  |  3  |
| `nextVal[j]` | -1  |  0  | -1  |  0  | -1  |  3  |
现在根据nextVal数组，作为失配的指针回溯标志，会发现比使用next数组更快，回溯的距离明显减小：

![](20260110004013816.jpg)

- **为什么这样优化是合理的？它是如何做到比next有更少的回溯，同时还能保证之前的字符一定是已经匹配的？**
	- 当我们把 `nextval[j]` 设为 `nextval[k]` 时，我们并没有改变“前缀等于后缀”的性质。我们只是在发现 $t[j]$ 和 $t[k]$ 字符相同后，认为 $t[k]$ 作为一个备选项也是无效的，所以直接查表找到了比 $k$ 更短的、同样满足“前缀等于后缀”条件的下一个备选项。