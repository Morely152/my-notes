---

---
--- 
> 声明：本篇笔记部分摘自[《Java核心技术（卷Ⅰ） - 机械工业出版社》](https://detail.tmall.com/item.htm?ali_refid=a3_420434_1006%3A1151895243%3AN%3AoB1xLXSDdjSpCunkFwpZbCtvD%2B6YEaA9%3A39f8fcdda956d1ec63523e9a6e9e2355&id=708821240842&mi_id=0000mg2-P7Ustbzeym2_6DxuUMLCpndkVCAGc5EaA_l8QQ0&mm_sceneid=1_0_128421313_0&priceTId=2147831a17554253371677975e1dca&spm=a21n57.1.hoverItem.2&utparam=%7B%22aplus_abtest%22%3A%226b956865e0df43cd4a6620880d877f11%22%7D&xxc=ad_ztc)及[Java教程-廖雪峰-2025-06-16](https://liaoxuefeng.com/books/java/introduction/index.html)，遵循[CC BY 4.0协议](https://creativecommons.org/licenses/by/4.0/legalcode.zh-hans)。
> 存在由AI生成的小部分内容，仅供参考，请仔细甄别可能存在的错误。
--- 
# 一、网络编程基础

在进行简单的应用开发时，我们或许能在本地完成所有的任务。但是当我们需要实现用户之间的交互（实时排行榜、即时聊天等），或者需要对用户进行管理（账户系统、消息推送等），我们就需要实现能够通过计算机网络通信的程序了，即我们需要实现网络编程。

在同一个网络中，如果两台设备使用的是同一种协议，那么它们就可以相互通信。很多个小网络组成的大网络，即“网络的网络”，就是所谓的**互联网**。想要联入互联网与广泛的计算机设备通信交流，需要使用TCP/IP协议。

## 1.IP地址与基本网络知识

在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机必须要有一个IP地址，也可能有多个IP地址。

IP地址分为IPv4和IPv6两种。IPv4采用32位地址，类似`101.202.99.12`，而IPv6采用128位地址，类似`2001:0DA8:100A:0000:0000:1020:F2F3:1428`。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前几乎耗尽，而IPv6的地址数量很多，可以保障一段时间内的网络设备的分配。

IP地址又分为公网IP地址和内网IP地址。公网IP地址可以直接被访问，内网IP地址只能在内网访问。内网IP地址类似于：

- 192.168.x.x
- 10.x.x.x

有一个特殊的IP地址，称之为本机地址，它总是`127.0.0.1`。

如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址`127.0.0.1`，还有一个IP地址，例如`101.202.99.12`，可以通过这个IP地址接入网络。

要判断两台计算机是否在同一网络，只需要判断它们的**网络号**是否相同：

```text
网络号 = IP地址 ＆ 子网掩码
```

例如，某台计算机的IP是`101.202.99.2`，子网掩码是`255.255.255.0`，那么该计算机的网络号是`101.202.99.2 & 255.255.255.0 = 101.202.99.0`。如果计算得出另一台计算机的网络号与之相同，那么这两台计算机可以直接通过网线通信；如果不同，就需要路由器或者交换机（称之为网关）来间接通信。网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫路由。

一台计算机的一个网卡会有3个关键配置：

- IP地址
- 子网掩码
- 网关IP

在CMD中，执行命令`ipconfig`可以查询到详细的网络配置信息：

![](20250925151220587.png)

## 2.域名

直接记忆和输入域名访问网站比较麻烦，我们通常使用`www.xxxx.com`或`www.xxxx.cn`这样的一串字符，即**域名**来访问网站。当我们在浏览器中输入域名时，域名服务器（DNS, Domain Name Server）会将域名转换成对应的ip地址返回给路由器，然后路由器再通过这个ip地址访问对应的服务器。

想要通过域名知道服务器的ip，只需要ping一下就可以了：

![](20250925203913858.png)

本机域名为`localhost`，它对应的IPv4地址是`127.0.0.1`,IPv6地址是`::1`。

## 3.网络模型

计算机网络模型采用了分层模型，每一层负责处理自己的操作。由ISO组织定义的标准计算机互联模型OSI将网络划分成了下面六个层次：

- **应用层**：提供应用程序之间的通信；
- **表示层**：处理数据格式，加解密等等；
- **会话层**：负责建立和维护会话；
- **传输层**：负责提供端到端的可靠传输；
- **网络层**：负责根据目标地址选择路由来传输数据；
- **链路层和物理层**：负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。

互联网实际使用的TCP/IP协议大致对应了上面的5层模型，分别是应用层、传输层、IP层、网络接口层。

## 4.常用协议

IP、TCP、UDP这三种网络协议都是互联网的核心协议，分属于**TCP/IP 协议族**的不同层级，职责分工明确，共同支撑数据在网络中的传输。

### ① IP 协议（Internet Protocol，网际协议）

- **层级**：网络层（负责 “找路”）
- **核心作用**：给数据包分配 “目标地址”（IP 地址），并通过路由器将数据包从 “源设备” 转发到 “目标设备”，是实现跨网络通信的基础。
- **关键特点**：
    - 无连接：发送数据前不与目标设备建立连接，直接发送；
    - 不可靠：不保证数据包一定送达、不保证顺序（可能丢包、乱序），也不检查数据完整性；
    - 面向数据包：以 “IP 数据包” 为单位传输数据。
- **类比**：类似快递的 “地址单”—— 只负责标注收件地址，确保包裹被送到正确的城市 / 小区，但不保证包裹不丢失、不损坏，也不管包裹送达顺序。

### ② TCP 协议（Transmission Control Protocol，传输控制协议）

- **层级**：传输层（负责 “可靠传输”）
- **核心作用**：在 IP 协议的基础上，为应用程序（如浏览器、微信）提供**可靠、有序、双向**的数据传输服务，解决 IP 协议 “不可靠” 的问题。
- **关键特点**：
    - 面向连接：传输前需通过 “三次握手” 建立连接（类似打电话时 “喂 -> 请讲 -> 好的” 确认），传输后通过 “四次挥手” 断开连接；
    - 可靠传输：通过 “确认机制”（收到数据后回复 “已收到”）、“重传机制”（丢包后重新发送）、“流量控制”（避免发送过快导致接收方拥堵）、“拥塞控制”（避免网络整体拥堵），确保数据不丢、不重、有序；
    - 面向字节流：将应用数据拆分为字节流，按序传输，接收方再重组。
- **适用场景**：对可靠性要求高的场景，如网页浏览（HTTP/HTTPS）、文件下载（FTP）、即时通讯的消息发送、邮件传输（SMTP）等。

### ③ UDP 协议（User Datagram Protocol，用户数据报协议）

- **层级**：传输层（负责 “快速传输”）
- **核心作用**：在 IP 协议基础上，以 “最快速度” 传输数据，不保证可靠性，追求低延迟。
- **关键特点**：
    - 无连接：无需建立 / 断开连接，直接发送数据，效率高；
    - 不可靠：不确认、不重传、不保证顺序，丢包风险高；
    - 面向数据报：数据以 “UDP 数据报” 为单位，直接发送，头部简单（仅 8 字节），开销小、速度快。
- **适用场景**：对延迟敏感、可接受少量丢包的场景，如视频通话（Zoom）、直播、游戏、实时语音（微信语音）、DNS 域名解析等。


下表是这三者的简单对比：

|协议|层级|核心能力|可靠性|速度|典型应用|
|---|---|---|---|---|---|
|IP|网络层|跨网络 “找路”（地址转发）|低|中等|所有互联网数据的基础转发|
|TCP|传输层|可靠、有序传输|高|中等|网页、文件下载、消息|
|UDP|传输层|快速、低延迟传输|低|高|视频通话、游戏、直播|

## 5.Socket套接字

Socket（套接字）是**实现网络中不同设备间进程通信的技术 / 编程接口**，是 TCP/IP 协议族在应用层的 “桥梁”—— 它封装了底层 TCP/UDP、IP 协议的复杂细节，让开发者无需直接操作协议栈，就能轻松编写客户端与服务器的通信代码。

### 核心本质：“通信的端点”

可以把 Socket 理解为网络通信中的 “电话”：

- 两台设备（如手机和微信服务器）要通信，需各自创建一个 Socket 作为 “通信端点”；
- 客户端通过自己的 Socket，向服务器的 Socket 发起连接 / 发送数据；
- 服务器通过自己的 Socket，接收连接 / 数据，再回传响应。

一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP/IP协议把数据传输到网络：

```
┌───────────┐                                ┌───────────┐
│Application│                                │Application│
├───────────┤                                ├───────────┤
│  Socket   │                                │  Socket   │
├───────────┤                                ├───────────┤
│    TCP    │                                │    TCP    │
├───────────┤     ┌──────┐      ┌──────┐     ├───────────┤
│    IP     │◀───▶│Router│◀────▶│Router│◀───▶│    IP     │
└───────────┘     └──────┘      └──────┘     └───────────┘
```

仅仅通过IP地址进行通信是不够的，同一台计算机同一时间会运行多个网络应用程序，例如浏览器、QQ、邮件客户端等。当操作系统接收到一个数据包的时候，如果只有IP地址，它没法判断应该发给哪个应用程序，所以，操作系统抽象出Socket接口，每个应用程序需要各自对应到不同的Socket，数据包才能根据Socket正确地发到对应的应用程序。

Socket由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为**IP地址加端口号**。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于**特权端口**，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。

使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当**服务器端**，它会主动监听某个指定的端口，另一个进程必须充当**客户端**，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了连接，双方后续就可以随时发送和接收数据。

因此，当Socket连接成功地在服务器端和客户端之间建立后：

- 对服务器端来说，它的Socket是服务器IP地址和指定的端口号；
- 对客户端来说，它的Socket是用户计算机的IP地址和一个由操作系统分配的随机端口号。

# 二、TCP编程

## 1.服务器端编程

TCP编程，顾名思义是编写基于TCP协议实现的网络程序。Java标准库提供了`ServerSocket`来实现监听指定IP的指定端口。通过`ServerSocket ss = new ServerSocket(端口号)`来监听计算机上所有网络接口的指定端口；若监听成功则通过无限循环来处理客户端的连接：

```java
while(true) {
	Socket socket = ss.accept();
	
	Thread t = new Handler(socket);
	t.start();
}
```

代码`ss.accept()`表示每当有新的客户端连接进来后，就返回一个`Socket`实例，这个`Socket`实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，我们就必须为每个新的`Socket`创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理,具体的处理逻辑写在子线程的`run()`方法中。这里也可以使用线程池来提高处理效率：

```java
// 创建一个线程池 (固定大小为100)
ExecutorService es = Executors.newFixedThreadPool(100);

while (true) {
    Socket socket = ss.accept();

    // 将任务提交给线程池处理，而非每次都创建新线程
    es.submit(new Handler(socket));
}
```

如果没有客户端连接进来，`accept()`方法会阻塞并一直等待。如果有多个客户端同时连接进来，`ServerSocket`会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用`accept()`就可以获取新的连接。

由于TCP是一种基于流的协议，建立对客户端的连接后，我们需要使用Socket流来处理数据的输入输出，这与C++的IO stream流类似，只不过输入和输出的目标是客户端而不是控制台了：

```java
// 定义数据输入流，用于接收客户端数据  
BufferedReader reader = new BufferedReader(  
        new InputStreamReader(sock.getInputStream(), StandardCharsets.UTF_8));  
// 定义数据输出流，用于向客户端发送响应，最后的true为autoFlush属性的值
PrintWriter writer = new PrintWriter(  
        new OutputStreamWriter(sock.getOutputStream(), StandardCharsets.UTF_8), true))；
```

根据上面的分析，我们可以写出一个比较完整的TCP程序，实现监听`localhost:6606`并且输出用户端输入的内容：

```java
// 注意这里需要将文件名改成主类对应的“Server.java”

import java.io.*;  
import java.net.*;  
import java.nio.charset.StandardCharsets;  
import java.util.concurrent.*;  
import java.net.SocketTimeoutException;  
  
public class Server {  
  
    private static final int PORT = 6606; // 服务器端口  
    private static final int TIMEOUT_MS = 10_000;   // 10 秒空闲超时  
  
    // 定义线程池（常驻4个线程，最多扩展到16个线程，拓展线程空闲超过60s就回收掉）  
    private static final ExecutorService POOL =  
            new ThreadPoolExecutor(4, 16, 60L, TimeUnit.SECONDS,  
                    /* 不允许缓冲排队，直接开新线程处理 */                    
                    new SynchronousQueue<>(),  
                    /* 当线程数已达 16 且队列仍无法插入时，由调用 execute 的线程（此处为main线程）同步执行该任务，起到背压效果 */                  new ThreadPoolExecutor.CallerRunsPolicy());  
  
    // 服务端的入口main方法  
    public static void main(String[] args) {  
  
        // 监听指定的端口  
        try (ServerSocket serverSocket = new ServerSocket(PORT)) {  
            System.out.println("服务端启动，监听端口: " + PORT);  
  
            // 使用无限循环来将每一个连接提交到线程池处理  
            while (true) {  
                // 接受连接请求，返回socket实例；会阻塞main线程直到成功建立连接  
                Socket socket = serverSocket.accept();  
                System.out.println("客户端连接成功: " + socket.getRemoteSocketAddress());  
                // 将socket提交给线程池处理  
                POOL.execute(new ClientTask(socket));  
            }  
        } catch (IOException e) {  
            // 输出错误信息  
            e.printStackTrace();  
        } finally {  
            // 服务器主进程结束时，关闭线程池  
            POOL.shutdown();  
        }  
    }  
  
    // 使用Runnable接口实现客户端任务线程类：  
    private static class ClientTask implements Runnable {  
        // 定义socket属性，便于构造客户端任务实例  
        private final Socket clientSocket;  
  
        // 构造方法  
        ClientTask(Socket socket) {  
            this.clientSocket = socket;  
        }  
  
        // 重写客户端服务线程的run方法  
        @Override  
        public void run() {  
            // 使用try-with-resources让socket、io stream都自动关闭  
            try (Socket sock = clientSocket;  
                 // 定义数据输入流，用于接收客户端数据  
                 BufferedReader reader = new BufferedReader(  
                         new InputStreamReader(sock.getInputStream(), StandardCharsets.UTF_8));  
                 // 定义数据输出流，用于向客户端发送响应  
                 PrintWriter writer = new PrintWriter(  
                         new OutputStreamWriter(sock.getOutputStream(), StandardCharsets.UTF_8), true)) {  
  
  
                sock.setSoTimeout(TIMEOUT_MS);   // 读操作阻塞 10 s，超时触发异常  
                String line;   // 存储客户端发送的消息  
                
                while (true) {  
                    try {  
                        line = reader.readLine();          // 阻塞直到收到一行或超时  
                        if (line == null) break;           // 客户端关闭连接  
                        System.out.println("服务端：成功接受客户端" + sock.getRemoteSocketAddress() + "的信息: " + line);  
                        writer.println("Server: Receive data OK!");    // 发送响应消息，使用println方法自动补充\n对应客户端接受结束  
                    } catch (SocketTimeoutException e) {   // 捕获输入流超时异常，主动断开连接  
                        System.out.println("客户端超时: " + sock.getRemoteSocketAddress());  
                        break;                             // 跳出循环，准备关闭  
                    }  
                }  
            } catch (IOException e) {  
                // 其他 IO 异常（客户端强制断开等）  
                System.out.println("连接异常: " + e.getMessage());  
            } finally {  
                System.out.println("客户端连接已关闭: " + clientSocket.getRemoteSocketAddress());  
            }  
        }  
    }  
}
```

## 2.调试ICP程序

为了调试ICP程序，我们需要模拟客户端与服务器建立连接并试图通信。这里记录两种调试方法：

### ① 使用CMD中的telnet调试

CMD自带的**telnet.exe**是一个“极简版”的TCP调试工具，可以很方便地发起TCP连接和简单通信，初次使用需要在控制面板中开启相关服务：

![](20250926155617637.png#bc)

然后启动cmd，执行下面的命令：

```bash
C:\users\%username%>telnet

# CMD标签变成“命令提示符-telnet”并显示下面的内容：
欢迎使用 Microsoft Telnet Client
Escape 字符为 'CTRL+]'
# 输入q退出
Microsoft Telnet>q

# 窗口回到之前的普通命令形式
C:\users\%username%>
```

这样就是telnet的运行与退出操作了。要连接`localhost`的`6606`端口，执行命令`telnet localhost 6606`即可：

 ```bash
 C:\Users\dell3>telnet localhost 6606
正在连接localhost...无法打开到主机的连接。 在端口 6606: 连接失败    
 ```

报告连接失败的原因是我们还没有启动服务器程序。在Intellij IDEA中运行上面的服务器端程序，可以看到这样的输出内容：

```bash
服务端启动，监听端口: 6606
```

然后我们再执行命令`telnet localhost 6606`，CMD的标签名变成Telnet localhost，同时IDEA控制台提示`客户端连接成功`的信息，表示TCP连接成功建立。

![](20250926160335620.png#bc)

超过十秒钟没有操作，服务器端会自动断开连接：

![](20250926160511450.png#bc)

重新执行命令`telnet localhost 6606`建立与服务器的连接，并且在命令行（现在变成了“客户端”）输入一些字符（如“Hello TCP！”）后按回车键，可以看到IDEA（服务器端）的控制台中输出了对应的内容`Hello TCP!`，同时客户端接收到服务器传来的响应信息`Server:Receive data OK!`：

![](20250926161300720.png#bc)

我们也可以测试使用线程池的情况下，服务端程序的并行处理能力，同时启动多个cmd窗口并且都通过telnet进行连接,然后发送一些消息：

![](20250926161956870.png#bc)

可以看到服务端确实是成功同时建立了3个连接，并且都实时接收了输入的信息并且及时返回了响应。

### ② 使用Apifox调试

Apifox的标语是“**API 设计、开发、测试一体化协作平台**”，是一款综合Postman、Swagger、Mock以及JMeter等软件功能的国产工具，一站式解决 API 设计、调试、Mock、自动化测试和文档分享中的主要工作，面向个人/小团队免费开放使用。[点击查看官网](https://apifox.com)

安装并登录Apifox后，我们先运行服务端的程序，开启对6606端口的监听；然后操作Apifox连接6606端口并进行通信测试。

首先建立一个新的TCP Socket接口：

![](20250927093128844.png#bc)

填入对应的配置信息：

![](20250927093258644.png#bc)

点击保存后，在出现的TCP Demo标签页内点击“+添加接口”按钮，填写适当的接口名称（如TCP Test）即可，其他的无需配置，点击右上角的“保存”按钮。创建好的连接如下图所示：

![](20250927093604623.png#bc)

点击“运行”，建立与服务器6606端口的连接，在“报文内容”中输入想要发送的信息后，点击“发送”，可以看到IDEA的控制台输出了接收到的信息，同时“返回报文”中显示了服务器传来的响应信息，表明我们建立了一次成功的TCP连接，并且发送了一些信息。

![](20250927093753994.png#bc)

> 这里为了方便，将服务器端和客户端都放在localhost，只是通过不同的端口来模拟网络连接；实际开发时往往将服务端程序部署在服务器上，通过服务器的公网IP和开放的端口号进行通信，但实际上不会有很大的差别，初期学习和简单的开发测试使用localhost双端口就足够了。

## 3.客户端编程

客户端同样需要通过Socket来通过域名/IP和端口号连接服务器实现TCP通信：

```java
Socket socket = new Socket("服务器IP/域名"， 端口号)；
```

然后也通过Socket流处理数据的输入输出：

```java
BufferedWriter writer = new BufferedWriter(
        new OutputStreamWriter(socket.getOutputStream(), StandardCharsets.UTF_8));
BufferedReader reader = new BufferedReader(  
        new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8)));
```

一个简单的客户端程序如下所示，主要功能是连接之前写的`localhost:6606`服务端程序并且进行通信：

```java
// 注意这里需要将文件名改成主类对应的“Server.java”

import java.io.*;  
import java.net.Socket;  
import java.nio.charset.StandardCharsets;  
import java.util.Scanner;  
  
public class Client {  
  
    public static void main(String[] args) {  
        // 配置服务器地址和端口信息  
        String serverAddress = "localhost";  
        int serverPort = 6606;  
  
        // 使用 try-with-resources 确保 Socket 和流被自动关闭  
        try (Socket socket = new Socket(serverAddress, serverPort);  
             // 输出流，用于向服务器发送数据  
             // 使用 BufferedWriter 和 OutputStreamWriter 处理输入输出，指定UTF-8·编码  
             BufferedWriter writer = new BufferedWriter(  
                     new OutputStreamWriter(socket.getOutputStream(), StandardCharsets.UTF_8));  
             BufferedReader reader = new BufferedReader(  
                     new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8))) {  
  
            System.out.println("成功连接到服务器 " + socket.getInetAddress() + ":" + socket.getPort());  
  
            // 创建一个Scanner用于从控制台读取用户输入  
            Scanner scanner = new Scanner(System.in);  
  
            // 主循环：读取输入 -> 发送 -> 接收响应  
            while (true) {  
                System.out.print("请输入要发送的消息 (输入 'bye' 退出): ");  
                String message = scanner.nextLine(); // 读取用户输入的一行  
  
                // 如果用户输入 "bye"，则结束循环  
                if ("bye".equalsIgnoreCase(message.trim())) {  
                    System.out.println("正在断开连接...");  
                    // 向服务器发送 "bye" 信号  
                    writer.write(message);  
                    writer.newLine(); // 发送换行符，表示一行结束  
                    writer.flush();  
                    break;  
                }  
  
                // 将用户输入的消息发送给服务器  
                writer.write(message);  
                writer.newLine(); // 发送换行符，表示一行结束  
                writer.flush();   // 确保数据立刻发送出去  
  
                System.out.println("已发送: " + message);  
  
                // 等待并接收服务器的响应  
                String response = reader.readLine();  
                if (response == null) {  
                    // 如果响应为null，说明服务器已关闭连接  
                    System.out.println("服务器已关闭连接。");  
                    break;  
                }  
  
                System.out.println("[服务器响应] " + response);  
            }  
  
            scanner.close();  
  
        } catch (IOException e) {  
            // 处理连接或IO异常  
            System.err.println("客户端发生错误: " + e.getMessage());  
            e.printStackTrace();  
        }  
  
        System.out.println("客户端已断开。");  
    }  
}
```

需要注意这两点：

1. 为什么使用`if ("bye".equalsIgnoreCase(message.trim()))`而不是`if (message.equals("bye"))`:
	- 首先`trim()`方法用于移除客户端输入中的空白符（空格、换行等），避免类似于`"bye "`、`"bye\n"`这样的字符跳过了结束的判断；
	- `equalsIgnoreCase()`方法会忽略大小写差异，是一种更广泛的判断，使得用户输入`Bye`也能够停止通信；
	- 如果是`message.equlas()`，如果`message`由于某些原因成为了`null`，就会触发`NullPointerException`，直接导致程序崩溃；但是如果写成`"bye".equals()`，字符串字面量不会是`null`，这样就安全得多；即使这时参数`message`为null，方法内部已经预料到了这样的情况并且会直接返回`false`而不是引发空指针异常。
2. 为什么每次发送数据后，都需要调用`writer.flush()`:
	- 以流的形式写入数据的时候，并不是一写入就立刻发送到网络，而是先写入内存缓冲区，直到缓冲区满了以后，才会一次性真正发送到网络
	- 如果每次传输的数据很少，我们希望写入数据之后立即发送，就需要手动调用`flush()`将缓冲区的内容发送出去。

## 4.服务端与客户端的通信

在我们分别编写了客户端和服务端的程序之后，可以测试一下能否实现TCP连接和通信：

- 在IDEA中新建项目，然后新建两个Java class,分别命名为`Server`和`client`；
- 将之前编写的服务端程序和客户端程序粘贴进来，分别运行；
- 可以看到服务端提示开启监听，客户端提示连接成功并且服务端也提示了客户端的接入；
- 在客户端输入一些字符并按回车发送，服务端收到相应的信息；
- 超过10秒没有发送新的信息，服务端自动超时断连。

![](20250927104831333.gif#bc)

>（Tips:如果打字比较慢可以将服务端的超时修改成20s或者1min，这样测试的时候就不会手忙脚乱了）

# 三、UDP编程

UDP编程比TCP编程要简单得多，因为这样的协议不用创建连接，数据包也是一次收发一个，没有流的概念。

由于我们使用UDP时也需要明确直到目标机器的IP地址和端口号，所以我们也需要使用Socket。需要注意的是，UDP端口和TCP端口各自使用一套独立的端口，即TCP和UDP可以同时占用同一个端口。

与TCP服务端一样，UDP的服务端也需要开启指定端口的监听：

```java
DatagramSocket ds = new DatagramSocket(端口号);
```

如果没有其他应用程序占据这个端口，那么监听成功，我们就使用一个无限循环来处理收到的UDP数据包：

```java
for (;;) { // 这里当然也可以写while(true)了
    ...
}
```

要接收一个UDP数据包，需要准备一个`byte[]`缓冲区，并通过`DatagramPacket`实现接收：

```java
byte[] buffer = new byte[1024];
DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
ds.receive(packet);
```

假设我们收取到的是一个`String`，那么，通过`DatagramPacket`返回的`packet.getOffset()`和`packet.getLength()`确定数据在缓冲区的起止位置：

```java
String s = new String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);
```

当服务器收到一个DatagramPacket后，通常必须立刻回复一个或多个UDP包，因为客户端地址在DatagramPacket中，每次收到的DatagramPacket可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。

发送UDP包也是通过`DatagramPacket`实现的，代码写法很清晰易懂：

```java
byte[] data = ...
packet.setData(data);
ds.send(packet);
```

于是我们可以写出这样的UDP服务端程序：

```java
// 注意文件名需为Server.java

import java.io.IOException;  
import java.net.DatagramPacket;  
import java.net.DatagramSocket;  
import java.net.SocketException;  
import java.nio.charset.StandardCharsets;  
  
public class Server {  
    public static void main(String[] args) throws IOException {  
  
        DatagramSocket ds = new DatagramSocket(6606); // 监听指定端口  
        System.out.println("服务端启动成功，监听端口" + ds.getLocalPort());  
  
        for (;;) { // 无限循环  
  
            // 数据缓冲区:  
            byte[] buffer = new byte[1024];  
  
            // 收取一个UDP数据包  
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);  
            ds.receive(packet);  
  
            // 收取到的数据存储在buffer中，指定起始位置和长度后将其按UTF-8编码转换为String:  
            String s = new String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);  
            // 打印收到的数据  
            System.out.println("接收到来自" + packet.getSocketAddress() + "的信息：" + s);  
  
            // 发送数据:  
            byte[] data = "ACK".getBytes(StandardCharsets.UTF_8);  
            packet.setData(data);  
            ds.send(packet);  
        }  
  
    }  
}
```

使用这样的CMD命令来向服务端发送数据（想要修改服务端地址和发送内容，只需要修改`[System.Net.IPAddress]`和`[System.Text.Encoding]`中的参数即可）：

```bash
powershell -Command "$c=New-Object System.Net.Sockets.UdpClient; $ep=New-Object System.Net.IPEndPoint([System.Net.IPAddress]::Parse('127.0.0.1'), 6606); $b=[System.Text.Encoding]::UTF8.GetBytes('hello'); $c.Send($b,$b.Length,$ep);"
```

运行结果如下，服务端成功接收到了客户端发送的信息：

![](20250928095319058.png)