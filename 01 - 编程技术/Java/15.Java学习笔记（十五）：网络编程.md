---

---
--- 
> 声明：本篇笔记部分摘自[《Java核心技术（卷Ⅰ） - 机械工业出版社》](https://detail.tmall.com/item.htm?ali_refid=a3_420434_1006%3A1151895243%3AN%3AoB1xLXSDdjSpCunkFwpZbCtvD%2B6YEaA9%3A39f8fcdda956d1ec63523e9a6e9e2355&id=708821240842&mi_id=0000mg2-P7Ustbzeym2_6DxuUMLCpndkVCAGc5EaA_l8QQ0&mm_sceneid=1_0_128421313_0&priceTId=2147831a17554253371677975e1dca&spm=a21n57.1.hoverItem.2&utparam=%7B%22aplus_abtest%22%3A%226b956865e0df43cd4a6620880d877f11%22%7D&xxc=ad_ztc)及[Java教程-廖雪峰-2025-06-16](https://liaoxuefeng.com/books/java/introduction/index.html)，遵循[CC BY 4.0协议](https://creativecommons.org/licenses/by/4.0/legalcode.zh-hans)。
> 存在由AI生成的小部分内容，仅供参考，请仔细甄别可能存在的错误。
--- 
# 一、网络编程基础

在进行简单的应用开发时，我们或许能在本地完成所有的任务。但是当我们需要实现用户之间的交互（实时排行榜、即时聊天等），或者需要对用户进行管理（账户系统、消息推送等），我们就需要实现能够通过计算机网络通信的程序了，即我们需要实现网络编程。

在同一个网络中，如果两台设备使用的是同一种协议，那么它们就可以相互通信。很多个小网络组成的大网络，即“网络的网络”，就是所谓的**互联网**。想要联入互联网与广泛的计算机设备通信交流，需要使用TCP/IP协议。

## 1.IP地址与基本网络知识

在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机必须要有一个IP地址，也可能有多个IP地址。

IP地址分为IPv4和IPv6两种。IPv4采用32位地址，类似`101.202.99.12`，而IPv6采用128位地址，类似`2001:0DA8:100A:0000:0000:1020:F2F3:1428`。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前几乎耗尽，而IPv6的地址数量很多，可以保障一段时间内的网络设备的分配。

IP地址又分为公网IP地址和内网IP地址。公网IP地址可以直接被访问，内网IP地址只能在内网访问。内网IP地址类似于：

- 192.168.x.x
- 10.x.x.x

有一个特殊的IP地址，称之为本机地址，它总是`127.0.0.1`。

如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址`127.0.0.1`，还有一个IP地址，例如`101.202.99.12`，可以通过这个IP地址接入网络。

要判断两台计算机是否在同一网络，只需要判断它们的**网络号**是否相同：

```text
网络号 = IP地址 ＆ 子网掩码
```

例如，某台计算机的IP是`101.202.99.2`，子网掩码是`255.255.255.0`，那么该计算机的网络号是`101.202.99.2 & 255.255.255.0 = 101.202.99.0`。如果计算得出另一台计算机的网络号与之相同，那么这两台计算机可以直接通过网线通信；如果不同，就需要路由器或者交换机（称之为网关）来间接通信。网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫路由。

一台计算机的一个网卡会有3个关键配置：

- IP地址
- 子网掩码
- 网关IP

在CMD中，执行命令`ipconfig`可以查询到详细的网络配置信息：

![](20250925151220587.png)



```java
import java.io.*;  
import java.net.*;  
  
public class Demo {  
    public static void main(String[] args) {  
        int port = 6606;  
  
        try (ServerSocket serverSocket = new ServerSocket(port)) {  
            System.out.println("服务端启动，监听端口: " + port);  
  
            // 循环接受多个客户端连接（避免接收一次就退出）  
            while (true) {  
                Socket clientSocket = serverSocket.accept();  
                System.out.println("客户端连接成功: " + clientSocket.getInetAddress());  
  
                // 1. 读取APIfox发送的请求数据（基于字节流）  
                try (InputStream in = clientSocket.getInputStream();  
                     // 2. 新增：向APIfox发送响应数据的输出流  
                     OutputStream out = clientSocket.getOutputStream()) {  
  
                    byte[] buffer = new byte[1024]; // 1KB缓冲区，可根据数据大小调整  
                    int bytesRead = in.read(buffer); // 读取APIfox发送的数据  
  
                    if (bytesRead > 0) {  
                        // 将字节数组转换为字符串（注意编码要和APIfox一致，默认UTF-8）  
                        String receivedData = new String(buffer, 0, bytesRead, "UTF-8");  
                        System.out.println("Server: Accept data OK: " + receivedData);  
  
                        // ---------------- 核心新增：发送响应给APIfox ----------------  
                        String response = "Server: Receive data OK！"; // 响应内容  
                        // 将响应字符串转为字节流，写入输出流（发送给APIfox）  
                        out.write(response.getBytes("UTF-8"));  
                        out.flush(); // 强制刷新缓冲区，确保响应立即发送（避免滞留）  
                    }  
  
                } catch (IOException e) {  
                    e.printStackTrace();  
                } finally {  
                    // 关闭客户端连接（一次请求-响应后断开，符合调试场景）  
                    clientSocket.close();  
                    System.out.println("客户端连接已关闭");  
                }  
            }  
  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}
```