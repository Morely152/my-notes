---

---
--- 
> 声明：本篇笔记摘自[《数据结构教程》 - 清华大学出版社](http://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC5%E7%89%88%EF%BC%89/22216268?fromModule=search-result_lemma)，遵循[CC BY 4.0协议](https://creativecommons.org/licenses/by/4.0/legalcode.zh-hans)。
> 存在由AI生成的小部分内容，仅供参考，请仔细甄别可能存在的错误。
--- 

# 一、基本概念

- **查找**：指在含有n个元素的表中找出关键字等于k的元素；
- **动态查找表**：在查找的同时，对表做修改（插入、删除）操作；
- **静态查找表**：查找的过程中不涉及对表的操作；
- **内查找**：查找过程在内存中进行；
- **外查找**：查找过程中需要访问外存（硬盘等）；
- **平均查找长度**：$ASL=\sum_{i=1}^{n}p_ic_i=\sum_{i=1}^{n}\frac{c_i}{n}=\frac{1}{n}\sum_{i=1}^{n}{c_i}$，其中n为查找表中的元素个数，$p_i = \frac{1}{n}$是查找第i个元素的概率，$c_i$是找到第i个元素所需的关键字比较次数；
	- 也就是说，**ASL=找到每个元素的次数之和/元素的个数**
- $ASL$分为$ASL_{成功}$和$ASL_{不成功}$，分别表示查找（不）成功情况下的平均比较次数；
- 一个比较算法的ASL越小，这个算法的性能就越好。
# 二、线性表的查找

线性表是一种最简单的查找表。这里只考虑顺序表的查找，顺序表属于静态查找表。

```cpp
typedef int KeyType;      // 定义关键字类型为int
typedef struct {          
	KeyType key;          // 关键字项
	InfoType data;        // 其他数据项，类型为InfoType
} RecType;                // 定义查找元素的类型
```
## 1.顺序查找

基本思路：顺着顺序表的一端向另一端遍历，将每一个元素的关键字与k比较

```cpp
int SeqSearch(RecType R[], int n, KeyType k) {
	int i = 0;
	while (i<n && R[i].key != k) {
		i++;
	}
	if (i >= n) {
		return 0;
	} else {
		return i+1;
	}
}
```

查找表中第n个元素，需要比较n次，故$c_i$的取值为i，其$ASL_{成功}$的计算如下：
$$
ASL_{成功}= \sum_{i=1}^{n} \frac{c_{i}}{n} =\sum_{i=1}^{n} \frac{i}{n}=\frac{1}{n}\sum_{i=1}^{n}i=\frac{1}{n}\times\frac{n(n+1)}{2}=\frac{n+1}{2}
$$
也就是说，查找第i个元素，平均情况下需要比较的次数约为表长的一半。

需要遍历整个表才能确定不存在某元素,故：
$$
ASL_{不成功}=n
$$
顺序查找的平均时间复杂度为O(n)。

在顺序查找时，可以在表尾添加一个**哨兵元素**。如果找到的是哨兵，可以确定不存在元素并退出，省去了判断越界的逻辑。
## 2.折半查找

**折半查找**又称二分查找，是一种很~~搞笑~~高效的查找方法：

折半查找的前提是线性表按关键字有序排列。进行查找时，取线性表的中间元素进行比较，就可以确定结果在其中一边，然后取这一边作为新的线性表，再次取中点元素比较关键字，又可以去掉一半…

算法设计如下：
```cpp
int BinSearch(RecType R[], int n, KeyType k) {
	int low, high=n-1, mid;     // mid是中点元素
	while (low <= high) {
		mid=(low+high)/2;
		if (k == R[mid].key) {  // 中点元素就是目标。直接返回结果
			return mid+1;
		}
		if (k<R[mid].key) {     // 结果落入左边，将右边界挪到中点元素处
			high=mid-1；
		} else {
			low=mid+1;          // 结果落入右边，将左边界挪到中点元素处
		}
	}
	return 0;
}
```

折半查找的过程可以用二叉树描述，把当前查找区间的中点元素作为根，将左子表和右子表构造的二叉树分别作为左子树和右子树，由此得到描述二分查找的**判定树**或**比较树**。

二分查找的平均时间复杂度为O(l$og_2n$)。虽然很快，但是要求线性表有序，且支持随机存取，所以只能使用顺序存储结构。

--- 
![](20260112004850696.png)

对$ASL_{成功}$的解释：分母上的一系列乘式，表示的是所有元素的查询次数之和，根据**ASL=找到每个元素的次数之和/元素的个数**，除以元素个数就可以得出成功查询的平均次数

---
## 3.索引存储结构

**索引存储结构**是指在存储数据的同时建立索引表，形式为（关键字，地址）。关键字**唯一标识**一个结点，地址作为指向该关键字的指针，也可以是顺序存储中的元素下标。

索引存储结构可以提高查询元素的效率，但是索引表的存储提高了内存的开销。
## 4.分块查找

**分块查找**是一种介于顺序查找和二分查找之间的处理方式。它将数据分为几块，其中的每一块的第一个元素和最后一个元素在整个表上有序，块内可以无序，如：
$$
R=((\textcolor{red}{1},2,4,3,\textcolor{red}{5}),(\textcolor{red}{6},8,12,9,\textcolor{red}{13}),(\textcolor{red}{15},14,53,\textcolor{red}{89}))
$$
标红的首尾元素，在整个表上的序列（1,5,6,13,15,89）是有序的，每一块的内部可以无序。这样一来，**先用二分查找确定元素在哪一块中，再使用顺序查找看具体在块内的哪一个地方**。
# 三、树表的查找

有时也需要在二叉树/树中查找元素，这里统称为**树表**，并且采用链式存储结构。
## 1.二叉排序树

### ① 二叉排序树的插入和创建

**二叉排序树**又称二叉搜索树，定义为：二叉排序树或者为空，或者满足以下性质：
1. 若根结点的左子树非空，那么左子树上的关键字均小于根结点关键字
2. 若根结点的右子树非空，那么右子树上的关键字均大于根结点关键字
3. 根节点的左右子树本身也各是一棵二叉排序树

二叉排序树的结点类型声明如下，使用孩子链存储结构：
```cpp
typedef struct node {
	KeyType key;                     // 关键字
	InfoType data;                   // 其他数据域
	struct node *lchild, *rchild;    // 左右孩子链
} BSTNode;
```

将数据元素插入二叉树的算法如下：
```cpp
BSTNode *InsertBST(BSTNode *bt, KeyType k) {
	if (bt == NULL) {
		bt=(BSTNode *)malloc(sizeof(BSTNode));
		bt->key=k;
		bt->lchild=bt->rchil=NULL;
	} else if (k<bt ->key) {
		bt->lchild = InsertBST(bt->lchild.k);
	} else if (k>bt ->key) {
		bt->rchild = InsertBST(bt->rchild.k);
	}
	return bt;
}
```

创建一棵二叉排序树的算法如下：
```cpp
BSTNode *CreateBST(KeyType a[], int n) {
	BSTNode *bt = NULL;
	int i = 0;
	while (i>n) {
		bt = InsertBST(bt, a[i]);
		i++;
	}
	return bt;
}
```

一个关键字集合有多个序列表示，不同的序列构建的二叉排序树可能不同。例如，对于序列1~9，采用两种序列构成的二叉排序树就是不同的：

![](20260112013010734.jpg)

树1：`(5,2,1,6,7,4,8,3,9)`
树2：`(1,2,3,4,5,6,7,8,9)`

通过序列构造二叉排序树：

- 对于序列中的每个元素，成为比他大的元素中，最小的元素的左孩子。如果不存在比它大的元素，插入到右下孩子。保证每一个"二叉"，都是这样的结构：

```text
  中
 /  \
小   大
```

### ② 二叉排序树的搜索

由于二叉排序树是 `小-中-大` 有序的，对它进行查找可以类似地看成二分查找。对应的算法如下：

```cpp
BSTNode *SearchBST(BSTNode *bt, KeyType k) {
	if (nt==NULL || bt->key==k) {
		return bt;
	}
	if (k<bt->key) {
		return SearchBST(bt->lchild.k);
	} else {
		return SearchBST(bt->rchild.k);
	}
}
```

--- 
![](20260112014911428.jpg)

--- 

### ② 二叉排序树的删除

删除结点时，不能将它的子树一起删除，而是需要调整结构，只去除一个结点的同时，保持二叉排序树的结构：

![](20260112015243521.jpg)
## 2.平衡二叉树

在含有n个结点的二叉排序树中，查找操作的执行时间与树形有关，最坏情况（又单支树\）的执行时间为O(n)。

为了避免这种情况，需要让二叉树尽可能“均匀”，即保持一定的“**平衡性**”，让它尽可能地发挥出二叉排序树的优良性能，达到O($log_2n$)。比较著名的平衡二叉树是**AVL树**。

- **平衡二叉树**：二叉树中每个结点的左右子树高度最多相差1；
- 在算法中，通常使用**平衡因子**（左子树高度-右子树高度）来具体实现平衡二叉树的定义；
- 如果一棵二叉树所有的结点都是平衡的（平衡因子在-1~1之间），那么这棵二叉树称为平衡二叉树。

平衡二叉树和二叉排序树在结点添加和删除的操作相同，只是多了一个检查失衡并通过旋转来“调和”的步骤：(参考视频：[平衡二叉树(AVL树)](https://www.bilibili.com/video/BV1tZ421q72h))

![](20260112022717685.png)
![](20260112024529361.png)

## 3.红黑树

> (由于时间不足，红黑树、B树、B+树留到后面有时间再补充，此处未完待续…)
## 4.B树

## 5.B+树

# 四、哈希表的查找

## 1.哈希表的基本概念

对于一个列表数据，构造一个**哈希函数**，将其中一个不重复的字段作为哈希函数的参数，映射到一串较小的不重复数值上，作为这些数据存储的数组下标，构造这样的线性表称为**哈希表**（散列表）

--- 
例：对于学生信息，表格存储如下：

| 学号        | 姓名   | 哈希值 |
| --------- | ---- | --- |
| 240709001 | 张三   | 1   |
| 240709002 | 李四   | 2   |
| 240709005 | 王二麻子 | 5   |
| ...       | ...  | ... |
| 240709142 | 刘六   | 142 |

构造哈希函数h(x)=x-240709000，得到的哈希值如上表所示，其值即为数据元素在列表中存储的下标。

---
- **哈希冲突**：对于不同的关键字，得出的哈希值相同
	- 这样的一组关键字称为**同义词**，哈希冲突也称同义词冲突
- **装填因子α**：哈希表中已存放的元素数n与地址空间大小m的比值
	- 装填因子越小，冲突的可能性越小，闲置的存储空间也越多
	- 一般将装填因子控制在**0.6-0.9**之间是合适的
## 2.哈希表的构造方法

构造哈希表的主要任务是，构造一个合适的哈希函数，满足以下几点：
1. 让元素都存储在一个尽可能小的数组中，减少内存开支
2. 尽量减少冲突的发生，让元素均匀排列在数组中

常见的哈希函数构造方法有以下几种：
### ①  直接定址法：$h(k) = k+c$

一般用于关键字是一串很大的连续数字时的处理，将其降到比较小的一串存储地址数值。

### ② 除留余数法：$h(k) = k \mod p\ \ \ (mod为求余运算，p\leqslant m)$

此方法计算简单，适用范围广，可以让元素集合中的关键字转换成的地址落到p个下标的概率均等，有效地减少了冲突的发生。研究表明，p取不大于m的素数效果最好。

### ③ 数字分析法：

此方法适合处理关键字混乱无序且位数很长的情况，对关键字的一些数位进行分析，挑选每个关键字中分布较为均匀的一位数或几位数的组合，作为关键字的哈希值，例如对如下的关键字序列，使用最后两位的组合作为哈希值：


| 数值           | 哈希值 |
| ------------ | --- |
| 923176**02** | 02  |
| 923368**75** | 75  |
| 927396**28** | 28  |
| 923436**34** | 34  |
| 927068**16** | 16  |
| 927746**28** | 28  |
| 923812**62** | 62  |
| 923942**20** | 20  |

## 3.哈希冲突的解决方法

### ① 开放地址法

即出现冲突后，规定后来的冲突元素的新位置与当前位置的关系

#### a.线性探测法

从发生冲突的地址开始，依次探测下一个地址（到达m-1处就从0开始），直到找到一个空位置。

这样做解决冲突很简答，但是会出现**堆积**现象，即探测插入的元素会导致其他非同义词元素的位置被占领，出现位置的争夺现象。
#### b.平方探测法

出现冲突后，新地址的探测序列为：
$$
d_i=(d_0 \pm i^2) \mod m \ \ \ \ \ \ \ \ \ (i \leqslant i \leqslant m-1)
$$
平方探测法一定程度上避免了堆积的发生，但是只能探测到约一半的内存空间。

---
![](20260112035625902.jpg)

---

除此之外，还有**伪随机序列法**、**双哈希函数**等开放地址解决冲突的方法，这里一笔带过。
### ② 拉链法

- **拉链法**：使用单链表连接所有同义词的存储方法。
	- 所有哈希地址为i的元素构成一个单链表，哈希表的地址空间为`0~m-1`，地址为i的单元存储指向对应单链表的首结点。

![](20260112040305901.jpg)

这里哈希表中存储的是链表头结点而不是元素值，所以装填因子可能会大于一，通常直接取1。

拉链法相对于开放地址法有些优点：
- 无堆积现象，不会发生非同义词冲突，平均查找长度小，性能较高。
- 动态分配结点，适合建表前不知道表长的情况
- 元素很大时，添加的指针域基本上可以忽略不计，装填因子可以大于等于1，内存使用效率极高
- 删除结点的操作，比开放地址法的存储方便
相对的一些缺点：
- 指针需要额外空间，数据量小时得不偿失

## 4.哈希表的运算算法

> 这一节较长，时间原因暂时忽略，后面再填坑
